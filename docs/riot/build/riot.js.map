{"version":3,"sources":["webpack:///riot/build/riot.js","webpack:///./docs/riot/index.js","webpack:///./build/riot/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./docs/riot/components/index.js","webpack:///./docs/riot/components/App.tag","webpack:///./docs/riot/components/Demos/TreeView/TreeViewDemo.tag","webpack:///./node_modules/riot/riot.js"],"names":["webpackJsonp","585","module","exports","__webpack_require__","_riot","_riot2","obj","__esModule","default","window","onload","mount","586","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","constructor","prototype","t","n","undefined","apply","this","r","e","i","l","call","m","c","d","o","Object","defineProperty","configurable","enumerable","get","hasOwnProperty","p","s","value","a","u","keys","forEach","last","length","in","filter","indexOf","notIn","is","isIn","reduce","contains","allIn","every","b","Array","isArray","from","f","assign","arguments","selection","draggable","droppable","drag","dataTransfer","setData","JSON","stringify","guard","types","array","ancestors","drop","tree","category","concat","pluck","backup","setTimeout","cancel","parse","paste","getData","filesystem","items","kind","webkitGetAsEntry","getAsFile","push","onDragStart","stopPropagation","inputs","dragndrop","onDrag","onDragOver","preventDefault","dropEffect","css","addClass","currentTarget","mixCss","requestAnimationFrame","onDragEnter","hasChildren","isAsync","hasClass","target","state","unfolded","set","onDragLeave","removeClass","onDrop","onDragEnd","onCancel","onSelect","neighbours","outputs","next","done","return","TypeError","visit","single","multiple","modifiers","control","meta","lastSelection","lastIndex","lastPivot","bind","shift","slice","g","h","v","y","O","x","D","j","w","disabled","toString","unfold-on-selection","isSelected","toggle-fold","opener-control","not-selected","no-child-selection","some","max-depth","maxDepth","isNaN","parseInt","depth","labels","search.placeholder","TreeView","opener","selected","folded","async","loading","nodrop","dragover","search","item","strategies","click","fold","display","noOpener","tag2","mixin","optsMixin","listenerMixin","eventType","callback","rootNode","onKey","autoMount","filtered","onSearch","trim","model","treeFilter","defaults","opts","onselect","RootNode","update","flatten","pop","map","Map","size","add","match","RegExp","classes","join","HTMLElement","className","split","debug","console","log","writable","Error","shallowCompare","fullMap","nestPrefix","startsWith","substring","ReferenceError","create","setPrototypeOf","__proto__","key","refresh","getPrototypeOf","isFolded","searched","isDisabled","isDraggable","isDroppable","ulCss","liCss","pending","unwrapPromise","then","catch","Promise","reject","onClick","getDragEvents","getModifierState","wrapDragNDrop","filterTree","init","on","updateOpts","_originalOpts","transitionMixin","transition","name","unmount","root","classList","remove","addEventListener","one","regulate","document","removeEventListener","getModel","filteredmodel","has","getChildModel","node","sort","getChildFiltered","getAncestors","TreeNode","rootEvents","tag","parent","587","webpackPolyfill","deprecate","paths","children","588","589","590","_interopRequireDefault","_extends","source","_this","_tools","_dragndrop","_TreeViewModel","_TreeViewModel2","dragImage","Image","src","options","files","displaytag","label","localeCompare","input","string","_","event","setDragImage","updateSelection","591","94","global","factory","isBoolAttr","RE_BOOL_ATTRS","test","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isWritable","descriptor","getOwnPropertyDescriptor","$$","selector","ctx","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","isSvg","el","ownerSVGElement","mkEl","createElementNS","SVG_NS","createElement","setInnerHTML","container","html","innerHTML","doc","DOMParser","parseFromString","ownerDocument","importNode","documentElement","appendChild","toggleVisibility","dom","show","style","remAttr","removeAttribute","styleObjectToString","acc","prop","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","curr","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","toCamel","str","replace","toUpperCase","extend","args","handleEvent","handler","ptag","__","srcElement","which","charCode","keyCode","settings$1","autoUpdate","preventUpdate","getImmediateCustomParentTag","isMounted","setEventHandler","eventName","cb","RE_EVENTS_PREFIX","listeners","RIOT_EVENTS_KEY","updateDataIs","expr","tagName","ref","_tag","ref$1","head","isVirtual","impl","__TAG_IMPL","initChildTag","attrs","makeReplaceVirtual","onUnmount","delName","dataIs","arrayishRemove","tags","normalizeAttrName","attrName","ATTRS_PREFIX","CASE_SENSITIVE_ATTRIBUTES","updateExpression","hasValue","isObj","attr","isToggle","SHOW_DIRECTIVE","HIDE_DIRECTIVE","isStyleAttr","isClassAttr","_riot_id","wasCreated","tmpl","isAttrRemoved","bool","isRtag","wasParsedOnce","IE_VERSION","nodeValue","hidden","updateAllExpressions","expressions","mkitem","base","pos","unmountRedundant","splice","moveNestedTags","this$1","moveChildTag","move","nextTag","moveVirtual","insert","makeVirtual","append","_each","hasKeys","mustReorder","LOOP_NO_REORDER_DIRECTIVE","getTagName","placeholder","child","getTag","ifExpr","CONDITIONAL_DIRECTIVE","isAnonymous","oldItems","LOOP_DIRECTIVE","loopKeys","isLoop","removeChild","frag","isObject$$1","doReorder","oldPos","isNew","mustAppend","mustCreate","Tag$1","cloneNode","index","arrayishAdd","parseExpressions","mustIncludeRoot","tagImpl","type","nodeType","hasExpr","IfExpr","IS_DIRECTIVE","attributes","parentElement","outerHTML","parseAttributes","REF_DIRECTIVES","RefExpr","specialTags","select","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","isSvg$$1","SVG","GENERIC","tblTags","Tag$2","onCreate","tag$1","class","mountTo","styleManager","inject","tag2$1","mount$1","pushTagsTo","riotTag","elem","allTags","selectTags","nodeList","_el","mixin$1","mix","mixins_id","store","globals","mixins","update$1","__TAGS_CACHE","unregister$1","instAttrs","setIsMounted","conf","skipAnonymous","skipAnonymousTags","implAttrs","isInline","propsInSyncWithParent","observable$1","virts","tail","uid","data","nextOpts","canTrigger","shouldUpdate","inheritFrom","trigger","instance","props","propsBlacklist","proto","getOwnPropertyNames","hasGetterSetter","isPrototypeOf","k","globalMixin","GLOBAL_MIXIN","mustKeepRoot","tagIndex","unmountAll","off","mustSync","newPos","skipDataIs","namedTag","ensureArray","dest","isArr","hasIndex","oldIndex","implClass","_innerHTML","replaceChild","sib","styleNode","cssTextProp","WIN","RE_SPECIAL_TAGS","RE_SPECIAL_TAGS_NO_OPTION","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","id","getElementsByTagName","styleSheet","cssText","skipRegex","prev","code","_skipRegex","start","re","RE_REGEX","beforeReChars","RE_VN_CHAR","wordsLastChar","end","beforeReWords","brackets","UNDEF","_loopback","_rewrite","bp","_cache","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCK2","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","_settings","R_MLCOMMS","R_STRINGS","S_QBLOCKS","FINDBRACES","(","[","{","_bp","unescapeStr","prevStr","isexpr","parts","pushQBlock","_pos","_lastIndex","slash","mark","qblocks","ch","rech","ix","settings","riot","_tmpl","_logErr","err","riotData","errorHandler","error","message","_getTmpl","Function","RE_DQUOTE","qstr","_parseExpr","RE_QBMARK","asText","cnt","RE_CSNAME","jsb","rightContext","mm","lv","ir","RE_BREND","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","version","callbacks","defineProperties","fns","arguments$1","arglen","misc","stub","pristine","current","attrValue","rawValue","hasExp","old","customParent","tagOrDom","__ref","refs","tr","th","td","col","core","Tag","unregister","util","vdom","observable","riot$1"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YCLA,IAAAC,GAAAD,EAAA,IDUIE,EAMJ,SAAgCC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,IANnDF,ECTpCD,GAAA,KACAA,EAAA,KAEAM,OAAOC,OAAS,WACZL,EAAAG,QAAKG,MAAM,ODmBTC,IACA,SAAUX,EAAQC,EAASC,IAEL,SAASF,GAAS,GAAIY,GAAgCC,EAA8BC,EAAkCC,EAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUZ,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXW,SAAyBX,EAAIa,cAAgBF,QAAUX,IAAQW,OAAOG,UAAY,eAAkBd,KE3BnZ,SAASe,EAAEC,GAAG,GAAG,UAAAN,EAAiBd,IAAS,UAAAc,EAAiBf,GAAOA,EAAOC,QAAQoB,EAAEnB,EAAQ,SAAc,CAAyCW,GAAQX,EAAA,KAARU,EAAA,MAAAU,MAAAR,EAAA,kBAAAF,KAAAW,MAAAtB,EAAAY,GAAAD,KAAAZ,EAAAC,QAAAa,KAA+IU,EAAK,SAASJ,GAAG,MAAO,UAASA,GAAG,QAASC,GAAEI,GAAG,GAAGC,EAAED,GAAG,MAAOC,GAAED,GAAGxB,OAAQ,IAAI0B,GAAED,EAAED,IAAIE,EAAEF,EAAEG,GAAE,EAAG3B,WAAY,OAAOmB,GAAEK,GAAGI,KAAKF,EAAE1B,QAAQ0B,EAAEA,EAAE1B,QAAQoB,GAAGM,EAAEC,GAAE,EAAGD,EAAE1B,QAAQ,GAAIyB,KAAK,OAAOL,GAAES,EAAEV,EAAEC,EAAEU,EAAEL,EAAEL,EAAEW,EAAE,SAASZ,EAAEM,EAAED,GAAGJ,EAAEY,EAAEb,EAAEM,IAAIQ,OAAOC,eAAef,EAAEM,GAAGU,cAAa,EAAGC,YAAW,EAAGC,IAAIb,KAAKJ,EAAEA,EAAE,SAASD,GAAG,GAAIM,GAAEN,GAAGA,EAAEd,WAAW,WAAW,MAAOc,GAAEb,SAAS,WAAW,MAAOa,GAAG,OAAOC,GAAEW,EAAEN,EAAE,IAAIA,GAAGA,GAAGL,EAAEY,EAAE,SAASb,EAAEC,GAAG,MAAOa,QAAOf,UAAUoB,eAAeV,KAAKT,EAAEC,IAAIA,EAAEmB,EAAE,GAAGnB,EAAEA,EAAEoB,EAAE,KAAK,SAASrB,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,GAAK,IAAIjB,GAAEC,EAAE,EAAGA,GAAEM,EAAEX,EAAE,QAAQ,WAAW,MAAOI,GAAEkB,GAAI,IAAIhB,GAAED,EAAE,GAAIA,GAAEM,EAAEX,EAAE,OAAO,WAAW,MAAOM,GAAEgB,GAAI,IAAIV,GAAEP,EAAE,GAAIA,GAAEM,EAAEX,EAAE,SAAS,WAAW,MAAOY,GAAEU,GAAI,IAAIF,GAAEf,EAAE,GAAIA,GAAEM,EAAEX,EAAE,UAAU,WAAW,MAAOoB,GAAEE,GAAI,IAAIA,GAAEjB,EAAE,GAAIA,GAAEM,EAAEX,EAAE,MAAM,WAAW,MAAOsB,GAAEA,GAAI,IAAIC,GAAElB,EAAE,GAAIA,GAAEM,EAAEX,EAAE,UAAU,WAAW,MAAOuB,GAAED,GAAI,IAAIZ,GAAEL,EAAE,GAAIA,GAAEM,EAAEX,EAAE,SAAS,WAAW,MAAOU,GAAEY,KAAK,SAAStB,EAAEK,GAAGL,EAAEpB,QAAQmB,GAAG,SAASA,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,GAAK,IAAIjB,GAAEC,EAAE,GAAIQ,QAAOW,KAAKpB,GAAGqB,QAAQ,SAAS1B,GAAG,YAAYA,GAAG,eAAeA,GAAGc,OAAOC,eAAed,EAAED,GAAGiB,YAAW,EAAGC,IAAI,WAAW,MAAOb,GAAEL,OAAQ,IAAIO,GAAED,EAAE,GAAIQ,QAAOW,KAAKlB,GAAGmB,QAAQ,SAAS1B,GAAG,YAAYA,GAAG,eAAeA,GAAGc,OAAOC,eAAed,EAAED,GAAGiB,YAAW,EAAGC,IAAI,WAAW,MAAOX,GAAEP,OAAQ,IAAIa,GAAEP,EAAE,GAAIQ,QAAOW,KAAKZ,GAAGa,QAAQ,SAAS1B,GAAG,YAAYA,GAAG,eAAeA,GAAGc,OAAOC,eAAed,EAAED,GAAGiB,YAAW,EAAGC,IAAI,WAAW,MAAOL,GAAEb,SAAS,SAASA,EAAEC,EAAEK,GAAG,YAAaA,GAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOI,IAAI,IAAIA,GAAE,SAASL,GAAG,OAAO2B,KAAK,WAAW,MAAO3B,GAAE4B,OAAO,EAAE5B,EAAEA,EAAE4B,OAAO,GAAG,MAAMC,GAAG,SAAS5B,EAAEK,GAAG,MAAON,GAAE8B,OAAO,SAAS9B,GAAG,MAAOC,GAAE8B,QAAQ/B,IAAI,KAAKM,GAAGA,EAAEN,OAAOgC,MAAM,SAAS/B,EAAEK,GAAG,MAAON,GAAE8B,OAAO,SAAS9B,GAAG,MAAOC,GAAE8B,QAAQ/B,GAAG,KAAKM,GAAGA,EAAEN,OAAOiC,GAAG,SAAShC,EAAEK,GAAG,GAAID,GAAEJ,EAAEiC,KAAK3B,MAAE,KAASF,KAAKA,EAAEQ,EAAEZ,EAAE+B,MAAMX,MAAE,KAASR,KAAKA,CAAE,OAAOb,GAAE8B,OAAO,SAAS9B,GAAG,MAAOO,GAAE4B,OAAO,SAASlC,EAAEK,GAAG,MAAOA,GAAEyB,QAAQ/B,IAAI,GAAGC,IAAG,IAAKoB,EAAEc,OAAO,SAASlC,EAAEK,GAAG,MAAOA,GAAEyB,QAAQ/B,GAAG,GAAGC,IAAG,MAAOK,GAAGA,EAAEN,OAAOoC,SAAS,SAASnC,GAAG,MAAOD,GAAE+B,QAAQ9B,IAAI,GAAGoC,MAAM,SAASpC,GAAG,MAAOD,GAAEsC,MAAM,SAAStC,GAAG,MAAOC,GAAE8B,QAAQ/B,IAAI,QAAQ,SAASA,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,GAAK,IAAIjB,GAAEC,EAAE,GAAIA,GAAEM,EAAEX,EAAE,WAAW,WAAW,MAAOI,GAAEkC,IAAIjC,EAAEM,EAAEX,EAAE,WAAW,WAAW,MAAOI,GAAEkB,GAAI,IAAIhB,GAAED,EAAE,EAAGA,GAAEM,EAAEX,EAAE,sBAAsB,WAAW,MAAOM,GAAEI,IAAIL,EAAEM,EAAEX,EAAE,kBAAkB,WAAW,MAAOM,GAAEgB,IAAIjB,EAAEM,EAAEX,EAAE,iBAAiB,WAAW,MAAOM,GAAEgC,GAAI,IAAI1B,GAAEP,EAAE,EAAGA,GAAEM,EAAEX,EAAE,WAAW,WAAW,MAAOY,GAAEU,GAAI,IAAIF,GAAEf,EAAE,EAAGA,GAAEM,EAAEX,EAAE,YAAY,WAAW,MAAOoB,GAAEE,IAAIjB,EAAEM,EAAEX,EAAE,QAAQ,WAAW,MAAOoB,GAAEV,IAAIL,EAAEM,EAAEX,EAAE,aAAa,WAAW,MAAOoB,GAAEkB,IAAIjC,EAAEM,EAAEX,EAAE,aAAa,WAAW,MAAOoB,GAAET,KAAK,SAASZ,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,GAAG,GAAGwC,MAAMC,QAAQzC,GAAG,CAAC,IAAI,GAAIC,GAAE,EAAEK,EAAEkC,MAAMxC,EAAE4B,QAAQ3B,EAAED,EAAE4B,OAAO3B,IAAIK,EAAEL,GAAGD,EAAEC,EAAG,OAAOK,GAAE,MAAOkC,OAAME,KAAK1C,GAAGM,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOoB,KAAIf,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOuB,KAAIlB,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAO0C,KAAIrC,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOW,IAAI,IAAIL,GAAED,EAAE,GAAGO,EAAEC,OAAO8B,QAAQ,SAAS5C,GAAG,IAAI,GAAIC,GAAE,EAAEA,EAAE4C,UAAUjB,OAAO3B,IAAI,CAAC,GAAIK,GAAEuC,UAAU5C,EAAG,KAAI,GAAII,KAAKC,GAAEQ,OAAOf,UAAUoB,eAAeV,KAAKH,EAAED,KAAKL,EAAEK,GAAGC,EAAED,IAAI,MAAOL,IAAGqB,GAAGyB,UAAU,SAAS9C,EAAEC,GAAG,OAAO8C,WAAU,EAAGC,WAAU,EAAGC,KAAK,SAASjD,EAAEC,EAAEK,GAAGL,EAAEiD,cAAcjD,EAAEiD,aAAaC,QAAQ,mBAAmBC,KAAKC,UAAU/C,EAAEwC,aAAaQ,MAAM,SAAStD,EAAEC,EAAEK,GAAG,QAAGL,GAAGA,EAAEiD,cAAcjD,EAAEiD,aAAaK,MAAMxB,QAAQ,oBAAoB,KAAkB,WAAW,MAAO/B,IAAGc,OAAOP,EAAEiD,OAAOlD,EAAEwC,WAAWV,SAASpC,OAAO,WAAW,MAAOM,GAAEmD,WAAWnD,EAAEmD,UAAUtB,OAAO,SAASnC,EAAEC,GAAG,MAAOD,IAAGc,OAAOP,EAAEiD,OAAOlD,EAAEwC,WAAWV,SAASnC,KAAI,QAAQyD,KAAK,SAASpD,EAAEO,EAAEQ,GAAG,GAAIE,GAAET,OAAOP,EAAEoD,MAAM3D,IAAIqB,EAAEuC,UAAU9B,OAAO,SAAS9B,GAAG,MAAOqB,GAAEyB,UAAUf,QAAQ/B,GAAG,IAAIwB,EAAElB,EAAEA,EAAEe,EAAEuC,WAAWtD,EAAEe,EAAEuC,mBAAoBpB,OAAMlC,EAAEQ,OAAOP,EAAEiD,OAAOnC,EAAEoC,WAAW9B,OAAO,IAAKH,GAAEA,EAAEH,EAAEuC,aAAaC,OAAOxD,EAAEmB,EAAEH,EAAEuC,WAAWvD,EAAEgB,EAAEyB,YAAYvB,KAAKsC,OAAOxD,EAAEkB,GAAGlB,EAAEgB,EAAEyB,YAAY7C,EAAEsB,MAAMuC,MAAM,SAAS9D,EAAEC,GAAG,OAAO8C,WAAU,EAAGgB,UAAUd,KAAK,SAAS3C,EAAED,EAAEQ,GAAGU,EAAE6B,KAAKC,UAAUrD,KAAKK,EAAE6C,cAAc7C,EAAE6C,aAAaC,QAAQ,mBAAmBC,KAAKC,UAAU/C,IAAI0D,WAAW,WAAW,MAAO/D,GAAEa,OAAOP,EAAEoD,MAAM3D,IAAIa,EAAE+C,UAAU9B,OAAO,SAAS9B,GAAG,MAAOA,KAAIM,MAAM,KAAK2D,OAAO,WAAWhE,EAAEmD,KAAKc,MAAM3C,OAAO4C,MAAM,SAASnE,EAAEC,GAAG,OAAO+C,WAAU,EAAGU,KAAK,SAASpD,EAAEO,EAAEQ,GAAG,GAAGR,EAAEqC,cAAcrC,EAAEqC,aAAaK,MAAMxB,QAAQ,qBAAqB,EAAE,CAAC,GAAIR,GAAE6B,KAAKc,MAAMrD,EAAEqC,aAAakB,QAAQ,qBAAqB5C,KAAKqC,OAAOxD,EAAEL,MAAMW,EAAEL,EAAEA,EAAEe,EAAEuC,WAAWtD,EAAEe,EAAEuC,mBAAoBpB,OAAMlC,EAAEQ,OAAOP,EAAEiD,OAAOnC,EAAEoC,WAAW9B,OAAO,IAAKhB,GAAEA,EAAEU,EAAEuC,aAAaC,OAAOxD,EAAEM,EAAEU,EAAEuC,YAAYrC,IAAIC,KAAKqC,OAAOxD,EAAEmB,IAAID,IAAItB,EAAEuB,QAAQD,EAAE,KAAKC,GAAG6C,WAAW,SAASrE,GAAG,GAAIC,GAAED,EAAEkD,aAAalD,EAAEkD,aAAaoB,MAAM,IAAK,IAAGrE,GAAGA,EAAE2B,OAAO,GAAG,SAAS3B,EAAE,GAAGsE,KAAK,CAAC,IAAI,GAAIjE,MAAKD,EAAE,EAAEA,EAAEJ,EAAE2B,OAAOvB,IAAI,CAAC,GAAIE,GAAEN,EAAEI,GAAGmE,oBAAoBvE,EAAEI,GAAGoE,WAAYlE,IAAGD,EAAEoE,KAAKnE,GAAG,MAAOD,GAAE,MAAO,QAAOK,GAAE,EAAGgC,GAAGgC,YAAY,SAAS3E,GAAG,MAAO,UAASC,GAAGA,EAAE2E,kBAAkBxE,KAAKyE,OAAO3D,MAAM4D,UAAUC,OAAO/E,EAAEC,EAAEG,KAAKyE,OAAO3D,SAAS8D,WAAW,SAAShF,GAAG,MAAO,UAASC,GAAGA,EAAEgF,iBAAiBhF,EAAE2E,kBAAkBjE,IAAIA,GAAE,EAAGP,KAAKyE,OAAO3D,MAAM4D,UAAUxB,OAAOlD,KAAKyE,OAAO3D,MAAM4D,UAAUxB,MAAMtD,EAAEC,EAAEG,KAAKyE,OAAO3D,QAAQjB,EAAEiD,eAAejD,EAAEiD,aAAagC,WAAW,QAAQ3E,EAAE4E,IAAIC,SAASnF,EAAEoF,cAAcjF,KAAKkF,OAAO,YAAY/E,EAAE4E,IAAIC,SAASnF,EAAEoF,cAAcjF,KAAKkF,OAAO,aAAaC,sBAAsB,WAAW5E,GAAE,OAAQ6E,YAAY,SAASxF,GAAG,MAAO,UAASC,GAAG,GAAGA,EAAEgF,iBAAiBhF,EAAE2E,kBAAkB5E,IAAII,KAAKqF,YAAYzF,IAAII,KAAKsF,QAAQ1F,KAAKO,EAAE4E,IAAIQ,SAAS1F,EAAE2F,OAAOxF,KAAKkF,OAAO,WAAW,CAAC,GAAIhF,GAAEF,KAAKyF,MAAM3E,MAAM4E,SAAShE,OAAO,SAAS7B,GAAG,MAAOA,KAAID,GAAIM,GAAEoE,KAAK1E,GAAGI,KAAKyF,MAAME,KAAKD,SAASxF,OAAO0F,YAAY,SAAShG,GAAGA,EAAE4E,kBAAkBrE,EAAE4E,IAAIc,YAAYjG,EAAEqF,cAAcjF,KAAKkF,OAAO,aAAa/E,EAAE4E,IAAIc,YAAYjG,EAAEqF,cAAcjF,KAAKkF,OAAO,YAAYY,OAAO,SAASlG,GAAG,MAAO,UAASC,GAAGA,EAAE2E,kBAAkBrE,EAAE4E,IAAIc,YAAYhG,EAAEoF,cAAcjF,KAAKkF,OAAO,aAAa/E,EAAE4E,IAAIc,YAAYhG,EAAEoF,cAAcjF,KAAKkF,OAAO,WAAWlF,KAAKyE,OAAO3D,MAAM4D,UAAUoB,OAAOlG,EAAEC,EAAEG,KAAKyE,OAAO3D,SAASiF,UAAU,SAASnG,GAAG,MAAO,UAASC,GAAGA,EAAE2E,kBAAkB3E,EAAEiD,cAAc,SAASjD,EAAEiD,aAAagC,YAAY9E,KAAKyE,OAAO3D,MAAM4D,UAAUsB,SAASpG,EAAEC,EAAEG,KAAKyE,OAAO3D,UAAUN,EAAE,WAAW,GAAIZ,GAAEI,IAAK,OAAOS,MAAKT,KAAKyE,OAAO3D,MAAM4D,WAAWC,OAAO,SAAS9E,EAAEK,EAAED,GAAGS,OAAOP,EAAEiD,OAAOxD,EAAE6E,OAAO3D,MAAM4B,WAAWV,SAASnC,IAAID,EAAEqG,SAASpG,EAAEI,EAAEoD,UAAUpD,EAAEiG,YAAYtG,EAAEuG,QAAQxB,QAAQ/E,EAAEuG,QAAQxB,OAAO9E,EAAEK,EAAED,IAAI6F,OAAO,SAASjG,EAAEK,EAAED,GAAGC,EAAE2E,iBAAiBjF,EAAEuG,QAAQL,QAAQlG,EAAEuG,QAAQL,OAAOjG,EAAEK,EAAED,IAAI+F,SAAS,SAASnG,EAAEK,EAAED,GAAGC,EAAE2E,iBAAiB3E,EAAE4C,cAAc,SAAS5C,EAAE4C,aAAagC,YAAYlF,EAAEuG,QAAQH,UAAUpG,EAAEuG,QAAQH,SAASnG,EAAEK,EAAED,QAAQ,SAASL,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,GAAG,GAAGwC,MAAMC,QAAQzC,GAAG,CAAC,IAAI,GAAIC,GAAE,EAAEK,EAAEkC,MAAMxC,EAAE4B,QAAQ3B,EAAED,EAAE4B,OAAO3B,IAAIK,EAAEL,GAAGD,EAAEC,EAAG,OAAOK,GAAE,MAAOkC,OAAME,KAAK1C,GAAGM,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOuB,KAAIlB,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOU,KAAIL,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAO0C,IAAI,IAAIpC,GAAED,EAAE,GAAGO,EAAE,WAAW,QAASb,GAAEA,EAAEC,GAAG,GAAIK,MAAKD,GAAE,EAAGE,GAAE,EAAGM,MAAE,EAAO,KAAI,IAAI,GAAIQ,GAAEE,EAAEvB,EAAEJ,OAAOC,cAAcQ,GAAGgB,EAAEE,EAAEiF,QAAQC,QAAQnG,EAAEoE,KAAKrD,EAAEC,QAAQrB,GAAGK,EAAEsB,SAAS3B,GAAGI,GAAE,IAAK,MAAML,GAAGO,GAAE,EAAGM,EAAEb,EAAvH,QAAiI,KAAKK,GAAGkB,EAAEmF,QAAQnF,EAAEmF,SAApB,QAAqC,GAAGnG,EAAE,KAAMM,IAAG,MAAOP,GAAE,MAAO,UAASL,EAAEK,GAAG,GAAGkC,MAAMC,QAAQxC,GAAG,MAAOA,EAAE,IAAGL,OAAOC,WAAYiB,QAAOb,GAAG,MAAOD,GAAEC,EAAEK,EAAG,MAAM,IAAIqG,WAAU,4DAA4DtF,EAAE,SAASrB,EAAEC,EAAEK,EAAED,GAAG,MAAOS,QAAOP,EAAEiD,OAAOvD,GAAGmC,SAASpC,OAAOA,IAAIuB,EAAE,SAASvB,EAAEC,EAAEK,EAAED,GAAG,GAAIQ,IAAE,EAAGQ,EAAEpB,EAAE6B,OAAO,SAAS7B,GAAG,MAAOY,KAAIA,EAAEZ,IAAID,GAAGC,IAAID,GAAGK,EAAE0B,QAAQ9B,GAAG,GAAI,QAAOY,GAAGb,EAAEI,KAAKyE,OAAO3D,MAAM0C,WAAW5D,EAAEI,KAAKyE,OAAO3D,MAAM0C,mBAAoBpB,QAAO1B,OAAOP,EAAEoD,MAAM3D,EAAEI,KAAKyE,OAAO3D,MAAM0C,UAAUxD,KAAKyE,OAAO3D,MAAM0C,UAAUgD,MAAM,SAAS5G,GAAGqB,EAAEP,OAAOP,EAAEiD,OAAOnC,GAAGW,MAAMhC,KAAKa,GAAGQ,EAAEqD,KAAK1E,GAAGqB,GAAGG,GAAGqF,OAAOxF,EAAEyF,SAASvF,EAAEwF,UAAU,SAAS/G,EAAEC,EAAEK,EAAEkB,GAAG,GAAIb,GAAEP,IAAK,IAAGA,KAAK2G,UAAUC,SAAS5G,KAAK2G,UAAUE,KAAK,MAAO7G,MAAK8G,cAAclH,QAASI,MAAK+G,gBAAiB/G,MAAKgH,UAAU7F,EAAE8F,KAAKjH,MAAMJ,EAAEC,EAAEK,EAAEkB,EAAG,IAAGpB,KAAK2G,UAAUO,MAAM,CAAC,IAAIlH,KAAK8G,cAAc,MAAOjH,EAAE,IAAI0C,GAAErC,EAAEyB,QAAQ3B,KAAK8G,cAAe,IAAGvE,EAAE,EAAE,MAAO1C,EAAE,IAAIW,GAAEX,EAAEsH,QAAQ/G,EAAEF,EAAEyB,QAAQ/B,EAAG,IAAG2C,GAAG,EAAE,CAAC,GAAIvB,EAAE,IAAGhB,KAAKgH,UAAU,CAAC,GAAII,GAAElH,EAAEyB,QAAQ3B,KAAKgH,WAAWK,EAAE9E,EAAE6E,GAAGA,EAAE7E,IAAIA,EAAE6E,GAAGE,EAAE7G,EAAE4G,EAAE,GAAGE,EAAED,EAAE,GAAGnF,EAAEmF,EAAE,GAAGhH,EAAEJ,EAAEiH,MAAMI,EAAEpF,EAAE,EAAG3B,GAAEE,OAAOP,EAAEiD,OAAO5C,GAAGoB,MAAMtB,GAAGN,KAAKgH,UAAUpH,CAAE,IAAI4H,GAAEjF,EAAEnC,GAAGA,EAAEmC,IAAIA,EAAEnC,GAAGqH,EAAEhH,EAAE+G,EAAE,GAAGE,EAAED,EAAE,GAAGE,EAAEF,EAAE,GAAGG,EAAE5H,KAAKyE,OAAO3D,MAAM+G,SAAS3H,EAAEiH,MAAMO,EAAEC,EAAE,GAAGjG,OAAO,SAAS9B,GAAG,OAAOW,EAAEkE,OAAO3D,MAAM+G,SAASjI,KAAKM,EAAEiH,MAAMO,EAAEC,EAAE,EAAGnH,GAAEE,OAAOP,EAAEiD,OAAO5C,GAAGoB,MAAMgG,IAAI5G,EAAER,GAAG8D,KAAKvE,MAAMiB,EAAEf,EAAE2H,IAAI,MAAOpH,GAAE,MAAOR,MAAK8G,cAAclH,QAASI,MAAK+G,gBAAiB/G,MAAKgH,UAAU/F,EAAEgG,KAAKjH,MAAMJ,EAAEC,EAAE2B,OAAO,KAAK3B,EAAEK,EAAEkB,IAAIiC,UAAU,SAASzD,GAAG,QAASC,GAAEA,EAAEK,EAAED,EAAEE,GAAG,MAAOP,GAAEG,MAAMC,KAAKyC,WAAW,MAAO5C,GAAEiI,SAAS,WAAW,MAAOlI,GAAEkI,YAAYjI,GAAG,SAASD,EAAEC,EAAEK,EAAEO,GAAG,MAAO,KAAIZ,EAAE2B,QAAQ5B,GAAGc,OAAOP,EAAEiD,OAAOvD,GAAGmC,SAASpC,MAAM6D,OAAOxD,EAAEQ,OAAOgD,OAAOxD,EAAEQ,IAAIb,OAAOW,GAAGwH,sBAAsB,SAASnI,GAAG,IAAII,KAAKgI,WAAWpI,GAAG,CAAC,GAAIC,GAAEG,KAAKyF,MAAM3E,MAAM4E,SAAShE,OAAO,SAAS7B,GAAG,MAAOA,KAAID,GAAIC,GAAEyE,KAAK1E,GAAGI,KAAKyF,MAAME,KAAKD,SAAS7F,MAAMoI,cAAc,SAASrI,GAAG,GAAIC,GAAEG,KAAKyF,MAAM3E,MAAM4E,SAAShE,OAAO,SAAS7B,GAAG,MAAOA,KAAID,GAAIC,GAAE2B,SAASxB,KAAKyF,MAAM3E,MAAM4E,SAASlE,QAAQ3B,EAAEyE,KAAK1E,GAAGI,KAAKyF,MAAME,KAAKD,SAAS7F,MAAM0C,GAAG2F,iBAAiB,SAAStI,GAAG,OAAOc,OAAOP,EAAEiD,OAAOpD,KAAKyF,MAAM3E,MAAM4E,UAAU1D,SAASpC,IAAIuI,eAAe,SAASvI,GAAG,OAAOI,KAAKgI,WAAWpI,IAAIwI,qBAAqB,SAASxI,GAAG,GAAIC,GAAEG,IAAK,QAAO,QAASJ,GAAEM,GAAG,MAAOL,GAAEmI,WAAW9H,IAAIA,EAAEL,EAAE4E,OAAO3D,MAAM0C,WAAWtD,EAAEL,EAAE4E,OAAO3D,MAAM0C,mBAAoBpB,QAAOlC,EAAEL,EAAE4E,OAAO3D,MAAM0C,UAAU6E,KAAKzI,IAAIA,IAAI0I,YAAY,WAAW,SAAStI,KAAKyE,OAAO3D,MAAMyH,UAAUC,MAAMC,SAASzI,KAAKyE,OAAO3D,MAAMyH,SAAS,OAAOvI,KAAKyE,OAAO3D,MAAM4H,OAAOD,SAASzI,KAAKyE,OAAO3D,MAAMyH,SAAS,OAAO,SAAS3I,EAAEC,EAAEK,GAAG,YAAaA,GAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOI,IAAI,IAAIA,IAAG0I,QAAQC,qBAAqB,cAAc7D,KAAK8D,SAAS,WAAWC,OAAO,SAASJ,MAAM,QAAQK,SAAS,WAAWvF,SAAS,WAAWwF,OAAO,SAASnB,SAAS,WAAWoB,MAAM,QAAQC,QAAQ,UAAUC,OAAO,SAASC,SAAS,WAAWC,OAAO,SAASC,KAAK,QAAQC,YAAY7G,WAAW,UAAU8G,SAASC,MAAM,eAAe,uBAAuBC,QAAQ,SAAS9J,GAAG,MAAOA,GAAEkI,YAAYmB,MAAM,SAASrJ,GAAG,MAAOA,MAAK+J,UAAS,EAAGjF,WAAW/B,WAAU,EAAGC,WAAU,KAAM,SAAShD,EAAEC,EAAEK,GAAG,YAAaA,GAAE,IAAI,SAASN,EAAEC,EAAEK,GAAG,YAAaA,GAAE,IAAIA,EAAE,IAAIA,EAAE,KAAK,SAASN,EAAEC,EAAEK,GAAGA,EAAE,GAAG0J,KAAK,WAAW,wgBAAwgB,GAAG,GAAG,SAAShK,GAAG,YAAa,IAAIC,GAAEa,OAAO8B,QAAQ,SAAS5C,GAAG,IAAI,GAAIC,GAAE,EAAEA,EAAE4C,UAAUjB,OAAO3B,IAAI,CAAC,GAAIK,GAAEuC,UAAU5C,EAAG,KAAI,GAAII,KAAKC,GAAEQ,OAAOf,UAAUoB,eAAeV,KAAKH,EAAED,KAAKL,EAAEK,GAAGC,EAAED,IAAI,MAAOL,IAAGK,EAAED,KAAKG,EAAED,EAAE,GAAGO,EAAEP,EAAE,GAAGe,EAAEf,EAAE,EAAGF,MAAK6J,OAAM,EAAG5I,EAAE6I,cAAc9J,KAAK6J,OAAM,EAAG5I,EAAE8I,gBAAgBC,UAAU,QAAQC,SAAS,SAASrK,GAAG,MAAOK,GAAEiK,SAASC,MAAMvK,IAAIwK,WAAU,KAAMpK,KAAK6J,OAAM,EAAG5I,EAAE8I,gBAAgBC,UAAU,UAAUC,SAAS,SAASrK,GAAG,MAAOK,GAAEiK,SAASC,MAAMvK,IAAIwK,WAAU,KAAMpK,KAAKqK,SAAS,KAAKrK,KAAKqJ,OAAO,GAAGrJ,KAAKsK,SAAS,SAAS1K,GAAG,GAAIC,GAAED,EAAEqF,cAAc/D,KAAMjB,GAAEoJ,OAAOxJ,EAAEI,EAAEoK,SAASxK,EAAE0K,QAAO,EAAGpK,EAAEoD,MAAMtD,EAAEwE,OAAO3D,MAAM0J,MAAMvK,EAAEwE,OAAO3D,MAAM0C,UAAUiH,WAAWxK,EAAEwE,OAAO3D,MAAMuI,OAAOxJ,EAAE0K,SAAS,MAAMvK,KAAKyE,QAAQ3D,IAAI,WAAW,MAAOjB,MAAKY,EAAEiK,SAASzK,EAAE0K,MAAM1E,SAAShG,EAAE0K,KAAKC,aAAa5K,KAAKmG,SAASF,SAASjG,KAAKyE,OAAO3D,MAAM8J,SAASjG,OAAO3E,KAAKyE,OAAO3D,MAAM4D,WAAW1E,KAAKyE,OAAO3D,MAAM4D,UAAU7B,KAAKiD,OAAO9F,KAAKyE,OAAO3D,MAAM4D,WAAW1E,KAAKyE,OAAO3D,MAAM4D,UAAUpB,KAAK0C,SAAShG,KAAKyE,OAAO3D,MAAM4D,WAAW1E,KAAKyE,OAAO3D,MAAM4D,UAAUb,QAAQ7D,KAAKyF,OAAO3E,IAAI,WAAW,MAAOjB,MAAKI,IAAI0F,IAAI,SAAS/F,GAAG,IAAI,GAAIC,KAAKD,GAAEC,IAAKI,KAAIA,EAAEJ,GAAGD,EAAEC,MAAMG,KAAKkK,SAAS,GAAIzJ,GAAEoK,SAAS7K,KAAKyE,OAAOzE,KAAKmG,QAAQnG,KAAKyF,MAAMzF,KAAK8K,WAAW,SAASlL,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,GAAG,GAAGwC,MAAMC,QAAQzC,GAAG,CAAC,IAAI,GAAIC,GAAE,EAAEK,EAAEkC,MAAMxC,EAAE4B,QAAQ3B,EAAED,EAAE4B,OAAO3B,IAAIK,EAAEL,GAAGD,EAAEC,EAAG,OAAOK,GAAE,MAAOkC,OAAME,KAAK1C,GAAGM,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOY,IAAI,IAAIN,GAAED,EAAE,GAAGO,EAAE,SAASb,EAAEC,GAAG,OAAOkL,QAAQ,WAAW,IAAI,GAAI7K,MAAKO,GAAGb,GAAGa,EAAEe,OAAO,GAAG,CAAC,GAAIP,GAAER,EAAEuK,KAAM/J,aAAamB,SAAQlC,KAAKuD,OAAOxD,EAAES,OAAOP,EAAEgB,GAAGjB,GAAG0B,MAAMX,IAAIhB,EAAEgB,IAAIR,KAAKgD,OAAOxD,EAAEQ,GAAGR,EAAEgB,EAAES,OAAO,SAAS9B,GAAG,MAAOA,GAAEC,KAAKoL,IAAI,SAASrL,GAAG,MAAOA,GAAEC,QAAQ,MAAOK,IAAGwB,OAAO,SAASxB,GAAG,GAAID,GAAEL,EAAE8B,OAAOxB,EAAG,OAAO,SAASN,GAAEK,GAAGA,EAAEqB,QAAQ,SAASrB,GAAGA,EAAEJ,IAAII,EAAEJ,YAAauC,SAAQnC,EAAEJ,GAAGI,EAAEJ,GAAG6B,OAAOxB,GAAGN,EAAEK,EAAEJ,QAAQI,GAAGA,GAAGwK,WAAW,SAASvK,GAAG,GAAID,GAAE,GAAIiL,IAAI,OAAO,SAAStL,GAAEK,EAAEE,GAAGF,EAAEqB,QAAQ,SAASrB,GAAG,GAAGA,EAAEJ,IAAII,EAAEJ,YAAauC,OAAM,CAAC,GAAI3B,GAAE,GAAIyK,IAAItL,GAAEK,EAAEJ,GAAGY,GAAGA,EAAE0K,KAAK,EAAEhL,EAAEwF,IAAI1F,EAAEQ,GAAGP,EAAED,IAAIE,EAAEwF,IAAI1F,EAAE,GAAIiL,UAAUhL,GAAED,IAAIE,EAAEwF,IAAI1F,EAAE,SAASL,EAAEK,GAAGA,GAAGmL,IAAI,SAASlL,EAAEC,GAAG,IAAI,GAAIM,IAAGb,GAAGa,EAAEe,OAAO,GAAG,CAAC,GAAIP,GAAER,EAAEuK,MAAM7J,EAAEF,EAAEU,QAAQzB,EAAG,IAAGiB,GAAG,GAAGF,EAAEE,GAAGtB,GAAG,MAAOoB,GAAEE,GAAGtB,GAAGoB,EAAEE,GAAGtB,GAAGsH,QAAQlG,EAAEE,GAAGtB,GAAGyE,KAAKnE,GAAGP,CAAEa,MAAKgD,OAAOxD,EAAEQ,GAAGR,EAAEgB,EAAES,OAAO,SAAS9B,GAAG,MAAOA,GAAEC,KAAKoL,IAAI,SAASrL,GAAG,MAAOA,GAAEC,OAAO,MAAOD,IAAG4G,MAAM,SAAStG,GAAG,IAAI,GAAID,IAAGL,GAAGK,EAAEuB,OAAO,GAAG,CAAC,GAAIrB,GAAEF,EAAE+K,KAAM9K,GAAEC,GAAGA,EAAEmB,QAAQ,SAAS1B,GAAG,MAAOA,GAAEC,IAAID,EAAEC,YAAauC,OAAMnC,EAAEqE,KAAK1E,EAAEC,IAAI,YAAY,SAASD,EAAEC,EAAEK,GAAG,YAAaA,GAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOI,IAAI,IAAIA,GAAE,SAASL,GAAG,OAAOoC,SAAS,SAASnC,GAAG,QAAQD,KAAKA,EAAEyL,MAAM,GAAIC,QAAO,KAAKzL,EAAE,KAAK,WAAW,SAASD,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,GAAG,GAAGwC,MAAMC,QAAQzC,GAAG,CAAC,IAAI,GAAIC,GAAE,EAAEK,EAAEkC,MAAMxC,EAAE4B,QAAQ3B,EAAED,EAAE4B,OAAO3B,IAAIK,EAAEL,GAAGD,EAAEC,EAAG,OAAOK,GAAE,MAAOkC,OAAME,KAAK1C,GAAGM,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOoB,IAAI,IAAId,GAAEO,OAAO8B,QAAQ,SAAS5C,GAAG,IAAI,GAAIC,GAAE,EAAEA,EAAE4C,UAAUjB,OAAO3B,IAAI,CAAC,GAAIK,GAAEuC,UAAU5C,EAAG,KAAI,GAAII,KAAKC,GAAEQ,OAAOf,UAAUoB,eAAeV,KAAKH,EAAED,KAAKL,EAAEK,GAAGC,EAAED,IAAI,MAAOL,IAAGa,EAAE,kBAAmBjB,SAAQ,UAAAD,EAAiBC,OAAOC,UAAS,SAASG,GAAG,gBAAcA,EAAd,YAAAL,EAAcK,IAAG,SAASA,GAAG,MAAOA,IAAG,kBAAmBJ,SAAQI,EAAEF,cAAcF,QAAQI,IAAIJ,OAAOG,UAAU,aAA3E,KAA2FC,EAA3F,YAAAL,EAA2FK,IAAGqB,EAAE,QAASrB,GAAEC,EAAEK,GAAG,GAAIe,GAAEwB,UAAUjB,OAAO,OAAG,KAASiB,UAAU,IAAIA,UAAU,EAAG,KAAI5C,IAAIK,GAAG,gBAAY,KAASL,EAAE,YAAYY,EAAEZ,KAAK,gBAAY,KAASK,EAAE,YAAYO,EAAEP,IAAI,MAAOL,EAAE,IAAIsB,GAAEhB,KAAKN,EAAEK,EAAG,KAAI,GAAIkB,KAAKlB,GAAEA,EAAEa,eAAeK,KAAKlB,EAAEkB,YAAagB,QAAOvC,EAAEuB,YAAagB,OAAMjB,EAAEC,GAAGH,KAAKwC,OAAOxD,EAAEJ,EAAEuB,IAAInB,EAAEC,EAAEkB,KAAKD,EAAEC,GAAGlB,EAAEkB,GAAG,WAAWX,EAAEP,EAAEkB,KAAK,WAAWX,EAAEZ,EAAEuB,MAAMD,EAAEC,GAAGxB,EAAEC,EAAEuB,GAAGlB,EAAEkB,GAAGH,IAAK,OAAOE,KAAI,SAASvB,EAAEC,EAAEK,GAAG,YAAaA,GAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOI,IAAI,IAAIA,IAAGsL,QAAQ,SAAS3L,GAAG,GAAIC,KAAK,KAAI,GAAIK,KAAKN,GAAEA,EAAEM,IAAIL,EAAEyE,KAAKpE,EAAG,OAAOL,GAAE2L,KAAK,MAAMxG,SAAS,SAASpF,EAAEC,GAAGD,YAAa6L,eAAc7L,EAAE8L,UAAU9L,EAAE8L,UAAUC,MAAM,KAAKjK,OAAO,SAAS9B,GAAG,MAAOA,KAAIC,IAAI2L,KAAK,KAAK,IAAI3L,IAAIgG,YAAY,SAASjG,EAAEC,GAAGD,YAAa6L,eAAc7L,EAAE8L,UAAU9L,EAAE8L,UAAUC,MAAM,KAAKjK,OAAO,SAAS9B,GAAG,MAAOA,KAAIC,IAAI2L,KAAK,OAAOjG,SAAS,SAAS3F,EAAEC,GAAG,MAAOD,aAAa6L,cAAa7L,EAAE8L,UAAU/J,QAAQ9B,IAAI,KAAK,SAASD,EAAEC,EAAEK,GAAG,YAAaA,GAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOI,IAAI,IAAIA,IAAG2L,MAAM,SAAShM,EAAEC,GAAG,GAAIK,GAAEuC,UAAUjB,OAAO,OAAG,KAASiB,UAAU,GAAGA,UAAU,GAAGoJ,QAAQC,GAAI5L,GAAE,aAAaN,EAAE,kHAAkH,oDAAoDM,EAAE,KAAKL,EAAE,qCAAqC,SAASD,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,EAAEC,EAAEK,GAAG,MAAOL,KAAKD,GAAEc,OAAOC,eAAef,EAAEC,GAAGqB,MAAMhB,EAAEW,YAAW,EAAGD,cAAa,EAAGmL,UAAS,IAAKnM,EAAEC,GAAGK,EAAEN,EAAEM,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOY,IAAI,IAAIN,GAAE,WAAW,QAASP,GAAEA,EAAEC,GAAG,GAAIK,MAAKD,GAAE,EAAGE,GAAE,EAAGM,MAAE,EAAO,KAAI,IAAI,GAAIQ,GAAEE,EAAEvB,EAAEJ,OAAOC,cAAcQ,GAAGgB,EAAEE,EAAEiF,QAAQC,QAAQnG,EAAEoE,KAAKrD,EAAEC,QAAQrB,GAAGK,EAAEsB,SAAS3B,GAAGI,GAAE,IAAK,MAAML,GAAGO,GAAE,EAAGM,EAAEb,EAAvH,QAAiI,KAAKK,GAAGkB,EAAEmF,QAAQnF,EAAEmF,SAApB,QAAqC,GAAGnG,EAAE,KAAMM,IAAG,MAAOP,GAAE,MAAO,UAASL,EAAEK,GAAG,GAAGkC,MAAMC,QAAQxC,GAAG,MAAOA,EAAE,IAAGL,OAAOC,WAAYiB,QAAOb,GAAG,MAAOD,GAAEC,EAAEK,EAAG,MAAM,IAAIqG,WAAU,4DAA4D9F,EAAE,SAASb,GAAG,KAAKA,GAAGA,YAAac,SAAQ,KAAM,IAAIsL,OAAM,oBAAqB,QAAOC,eAAe,SAASpM,EAAEK,GAAG,GAAID,IAAE,CAAG,KAAI,GAAIE,KAAKP,GAAE,GAAGA,EAAEmB,eAAeZ,MAAMD,GAAGA,EAAEyB,QAAQxB,IAAI,IAAIN,EAAEM,KAAKP,EAAEO,GAAG,YAAYF,GAAE,EAAI,OAAOA,IAAGyB,OAAO,SAAS7B,GAAG,GAAIK,KAAK,KAAI,GAAID,KAAKL,GAAEA,EAAEmB,eAAed,IAAIJ,EAAED,EAAEK,MAAMC,EAAED,GAAGL,EAAEK,GAAI,OAAOC,IAAG+K,IAAI,SAASpL,GAAG,GAAIK,KAAK,KAAI,GAAID,KAAKL,GAAEA,EAAEmB,eAAed,KAAKC,EAAED,GAAGJ,EAAED,EAAEK,IAAK,OAAOC,IAAGgM,QAAQ,SAASrM,GAAG,GAAIK,KAAK,KAAI,GAAID,KAAKL,GAAE,GAAGA,EAAEmB,eAAed,GAAG,CAAC,GAAIQ,GAAEZ,EAAEI,EAAEL,EAAEK,IAAIgB,EAAEd,EAAEM,EAAE,GAAGU,EAAEF,EAAE,GAAGG,EAAEH,EAAE,EAAGf,GAAEiB,GAAGC,EAAE,MAAOlB,IAAGiM,WAAW,SAAStM,GAAG,GAAIK,GAAEuC,UAAUjB,OAAO,OAAG,KAASiB,UAAU,GAAGA,UAAU,GAAG,SAAS7C,GAAG,MAAOA,IAAGO,EAAEF,KAAKJ,KAAM,KAAI,GAAIY,KAAKb,GAAEA,EAAEmB,eAAeN,IAAIA,EAAE2L,WAAWvM,GAAGM,EAAEN,GAAGK,EAAEO,EAAE4L,UAAUxM,EAAE2B,UAAU5B,EAAEa,GAAGN,EAAEM,GAAGb,EAAEa,EAAG,OAAON,OAAM,SAASP,EAAEC,EAAEK,GAAG,YAAa,SAASD,GAAEL,EAAEC,EAAEK,GAAG,MAAOL,KAAKD,GAAEc,OAAOC,eAAef,EAAEC,GAAGqB,MAAMhB,EAAEW,YAAW,EAAGD,cAAa,EAAGmL,UAAS,IAAKnM,EAAEC,GAAGK,EAAEN,EAAE,QAASO,GAAEP,EAAEC,GAAG,IAAID,EAAE,KAAM,IAAI0M,gBAAe,4DAA6D,QAAOzM,GAAG,oBAAiBA,EAAjB,YAAAN,EAAiBM,KAAG,kBAAmBA,GAAED,EAAEC,EAAE,QAASY,GAAEb,EAAEC,GAAG,GAAG,kBAAmBA,IAAG,OAAOA,EAAE,KAAM,IAAI0G,WAAU,qEAAkE1G,EAAlE,YAAAN,EAAkEM,IAAGD,GAAED,UAAUe,OAAO6L,OAAO1M,GAAGA,EAAEF,WAAWD,aAAawB,MAAMtB,EAAEiB,YAAW,EAAGkL,UAAS,EAAGnL,cAAa,KAAMf,IAAIa,OAAO8L,eAAe9L,OAAO8L,eAAe5M,EAAEC,GAAGD,EAAE6M,UAAU5M,GAAG,QAASoB,GAAErB,EAAEC,GAAG,KAAKD,YAAaC,IAAG,KAAM,IAAI0G,WAAU,qCAAqCrG,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOmB,KAAId,EAAEM,EAAEX,EAAE,IAAI,WAAW,MAAOuH,IAAI,IAAIjG,GAAEjB,EAAE,GAAGkB,EAAElB,EAAE,GAAGK,EAAEL,EAAE,GAAGqC,EAAErC,EAAE,GAAGM,EAAE,WAAW,QAASZ,GAAEA,EAAEC,GAAG,IAAI,GAAIK,GAAE,EAAEA,EAAEL,EAAE2B,OAAOtB,IAAI,CAAC,GAAID,GAAEJ,EAAEK,EAAGD,GAAEY,WAAWZ,EAAEY,aAAY,EAAGZ,EAAEW,cAAa,EAAG,SAAUX,KAAIA,EAAE8L,UAAS,GAAIrL,OAAOC,eAAef,EAAEK,EAAEyM,IAAIzM,IAAI,MAAO,UAASJ,EAAEK,EAAED,GAAG,MAAOC,IAAGN,EAAEC,EAAEF,UAAUO,GAAGD,GAAGL,EAAEC,EAAEI,GAAGJ,MAAMO,EAAE,QAASR,GAAEC,EAAEK,EAAED,EAAEE,GAAGc,EAAEjB,KAAKJ,GAAGI,KAAKyE,OAAO5E,EAAEG,KAAKmG,QAAQjG,EAAEF,KAAKyF,MAAMxF,EAAED,KAAK2M,QAAQxM,GAAGa,EAAE,SAASpB,GAAG,QAASC,KAAI,GAAID,GAAEM,EAAEO,EAAED,CAAES,GAAEjB,KAAKH,EAAG,KAAI,GAAIO,GAAEqC,UAAUjB,OAAOR,EAAEoB,MAAMhC,GAAGgH,EAAE,EAAEA,EAAEhH,EAAEgH,IAAIpG,EAAEoG,GAAG3E,UAAU2E,EAAG,OAAOlH,GAAEO,EAAEN,EAAEH,MAAMJ,EAAEC,EAAE4M,WAAW/L,OAAOkM,eAAe/M,IAAIQ,KAAKN,MAAMH,GAAGI,MAAMyD,OAAOzC,KAAKP,EAAEuH,WAAW,SAASpI,GAAG,MAAOc,QAAOS,EAAEiC,OAAO3C,EAAEgE,OAAO3D,MAAM4B,WAAWV,SAASpC,IAAIa,EAAEoM,SAAS,SAASjN,GAAG,GAAIC,GAAEY,EAAEgE,OAAO3D,MAAMyI,UAAW,SAAQ9I,EAAEgE,OAAO3D,MAAMgM,UAAUrM,EAAE6E,QAAQ1F,MAAMC,GAAGA,EAAE4J,UAAUwB,IAAI,SAASrL,GAAG,OAAOW,EAAE4B,EAAEvC,IAAIA,GAAGqH,KAAKxG,KAAKsB,OAAO,SAASlC,EAAEK,GAAG,MAAOL,IAAGK,EAAEN,EAAEC,KAAI,IAAKY,EAAE4E,YAAY,SAASzF,GAAG,MAAOA,GAAEa,EAAEgE,OAAO3D,MAAM0C,WAAW5D,EAAEa,EAAEgE,OAAO3D,MAAM0C,mBAAoBpB,QAAO3B,EAAE6E,QAAQ,SAAS1F,GAAG,QAAQA,IAAIa,EAAEgE,OAAO3D,MAAM0C,WAAW,kBAAmB5D,GAAEa,EAAEgE,OAAO3D,MAAM0C,WAAW/C,EAAEsM,WAAW,SAASnN,GAAG,GAAIC,GAAEY,EAAEgE,OAAO3D,MAAM+G,QAAS,SAAQhI,GAAGA,EAAED,IAAIa,EAAEuM,YAAY,SAASpN,GAAG,MAAOA,IAAGa,EAAEgE,OAAO3D,MAAM4D,UAAU/B,YAAY,kBAAmBlC,GAAEgE,OAAO3D,MAAM4D,UAAU/B,WAAWlC,EAAEgE,OAAO3D,MAAM4D,UAAU/B,UAAU/C,KAAKa,EAAEwM,YAAY,SAASrN,GAAG,MAAOa,GAAEgE,OAAO3D,MAAM4D,UAAU9B,YAAY,kBAAmBnC,GAAEgE,OAAO3D,MAAM4D,UAAU9B,WAAWnC,EAAEgE,OAAO3D,MAAM4D,UAAU9B,UAAUhD,KAAKa,EAAEyE,OAAO,SAAStF,GAAG,MAAOa,GAAEgE,OAAO3D,MAAMiE,IAAInF,IAAI2C,EAAEpB,EAAE4D,IAAInF,IAAIa,EAAEyM,MAAM,WAAW,MAAO/L,GAAE4D,IAAIwG,QAAQtL,KAAKQ,EAAEyE,OAAO,SAAS,KAAKzE,EAAEgE,OAAO3D,MAAM4H,OAAO,IAAG,KAAMjI,EAAE0M,MAAM,SAASvN,GAAG,GAAIC,EAAE,OAAOsB,GAAE4D,IAAIwG,SAAS1L,KAAKI,EAAEJ,EAAEY,EAAEyE,OAAO,YAAYzE,EAAEuH,WAAWpI,IAAIK,EAAEJ,EAAEY,EAAEyE,OAAO,YAAYzE,EAAE4E,YAAYzF,IAAIa,EAAE6E,QAAQ1F,IAAIK,EAAEJ,EAAEY,EAAEyE,OAAO,UAAUzE,EAAE4E,YAAYzF,IAAIa,EAAE6E,QAAQ1F,GAAGa,EAAEoM,SAASjN,GAAG,MAAMK,EAAEJ,EAAEY,EAAEyE,OAAO,YAAYzE,EAAEsM,WAAWnN,IAAIK,EAAEJ,EAAEY,EAAEyE,OAAO,SAASzE,EAAE6E,QAAQ1F,IAAIa,EAAEoM,SAASjN,IAAIK,EAAEJ,EAAEY,EAAEyE,OAAO,WAAWzE,EAAE6E,QAAQ1F,KAAKa,EAAEoM,SAASjN,IAAIC,KAAKY,EAAE2M,WAAW3M,EAAE4M,cAAc,SAASzN,GAAGa,EAAE2M,QAAQ9I,KAAK1E,EAAG,IAAIC,GAAEY,EAAEgE,OAAO3D,MAAMmI,KAAM,OAAOpJ,GAAEA,EAAED,EAAEa,EAAEgE,OAAO3D,MAAM0C,WAAW8J,KAAK,SAASzN,GAAGD,EAAEa,EAAEgE,OAAO3D,MAAM0C,UAAU3D,EAAEY,EAAEkM,YAAYY,MAAM,SAAS3N,GAAG,KAAMA,KAAI0N,KAAK,WAAW,MAAO7M,GAAE2M,QAAQ3M,EAAE2M,QAAQ1L,OAAO,SAAS7B,GAAG,MAAOA,KAAID,MAAM4N,QAAQC,OAAO,GAAIzB,OAAM,6BAA6BvL,EAAEiN,QAAQ,SAAS9N,GAAG,MAAO,UAASC,GAAG,IAAIY,EAAEsM,WAAWnN,GAAG,CAAC,GAAIM,GAAEO,EAAEgE,OAAO3D,MAAMyI,YAAYrJ,GAAGA,EAAEsJ,WAAWyB,IAAI,SAASrL,GAAG,OAAOW,EAAEY,EAAEvB,IAAIA,GAAGqH,KAAKxG,KAAKa,QAAQ,SAASpB,GAAG,MAAOA,GAAEN,EAAEC,EAAEY,EAAEgE,OAAO3D,MAAMuC,UAAU5C,EAAEgE,OAAO3D,MAAM0J,SAAS/J,EAAEgE,OAAO3D,MAAMmF,SAASrG,EAAEa,EAAEgE,OAAO3D,MAAMuC,UAAU5C,EAAEgE,OAAO3D,MAAM0J,OAAO3K,EAAE2E,qBAAqB/D,EAAEkN,cAAc,SAAS/N,GAAG,GAAG6C,UAAUjB,OAAO,OAAG,KAASiB,UAAU,KAAKA,UAAU,GAAG,QAAS,IAAI5C,IAAG8C,UAAUlC,EAAEuM,YAAYpN,GAAG2E,YAAY9D,EAAEuM,YAAYpN,IAAIwB,EAAEe,EAAEoC,YAAY3E,GAAGqH,KAAKxG,GAAGmE,WAAWnE,EAAEwM,YAAYrN,IAAIwB,EAAEe,EAAEyC,WAAWhF,GAAGqH,KAAKxG,GAAG2E,YAAY3E,EAAEwM,YAAYrN,IAAIwB,EAAEe,EAAEiD,YAAYxF,GAAGqH,KAAKxG,GAAGmF,YAAYnF,EAAEwM,YAAYrN,IAAIwB,EAAEe,EAAEyD,YAAYqB,KAAKxG,GAAGqF,OAAOrF,EAAEwM,YAAYrN,IAAIwB,EAAEe,EAAE2D,OAAOlG,GAAGqH,KAAKxG,GAAGsF,UAAUtF,EAAEuM,YAAYpN,IAAIwB,EAAEe,EAAE4D,UAAUnG,GAAGqH,KAAKxG,GAAI,KAAI,GAAIP,KAAKL,GAAEA,EAAEK,UAAWL,GAAEK,EAAG,OAAOL,IAAGW,EAAEN,EAAEC,EAAEM,EAAED,GAAG,MAAOC,GAAEZ,EAAED,GAAGY,EAAEX,IAAI6M,IAAI,WAAWxL,MAAM,SAAStB,GAAG,GAAIC,GAAEG,IAAK,OAAO,UAASE,GAAG,GAAID,GAAEJ,EAAE4F,MAAM3E,MAAM4E,SAAShE,OAAO,SAAS7B,GAAG,MAAOA,KAAID,GAAIK,GAAEuB,SAAS3B,EAAE4F,MAAM3E,MAAM4E,SAASlE,QAAQvB,EAAEqE,KAAK1E,GAAGC,EAAE4F,MAAME,KAAKD,SAASzF,IAAIC,EAAEsE,uBAAuB3E,GAAGO,GAAGgH,EAAE,SAASxH,GAAG,QAASC,KAAI,GAAID,GAAEM,EAAED,EAAEQ,CAAEQ,GAAEjB,KAAKH,EAAG,KAAI,GAAIW,GAAEiC,UAAUjB,OAAOpB,EAAEgC,MAAM5B,GAAGQ,EAAE,EAAEA,EAAER,EAAEQ,IAAIZ,EAAEY,GAAGyB,UAAUzB,EAAG,OAAOd,GAAED,EAAEE,EAAEH,MAAMJ,EAAEC,EAAE4M,WAAW/L,OAAOkM,eAAe/M,IAAIQ,KAAKN,MAAMH,GAAGI,MAAMyD,OAAOrD,KAAKH,EAAE0G,aAAa1G,EAAEkK,MAAM,SAASvK,GAAGK,EAAE0G,WAAWC,QAAQhH,EAAEgO,iBAAiB,WAAW/G,KAAKjH,EAAEgO,iBAAiB,QAAQ1G,MAAMtH,EAAEgO,iBAAiB,WAAW3N,EAAEgG,SAAS,SAASrG,EAAEC,EAAEK,GAAG,GAAIC,GAAEF,EAAEwE,OAAO3D,MAAMyI,WAAW7G,cAAcjC,EAAEN,EAAE8K,IAAI,SAASrL,GAAG,OAAOW,EAAEA,EAAEX,IAAIA,GAAGqH,KAAKhH,KAAK8B,OAAO,SAAS9B,EAAEE,GAAG,MAAOA,GAAEP,EAAEK,EAAEC,EAAEL,IAAII,EAAEwE,OAAO3D,MAAM4B,UAAW,OAAOzC,GAAEkG,QAAQF,SAASxF,EAAEb,EAAEC,EAAEK,GAAGO,GAAGR,EAAE4N,cAAczM,EAAEZ,EAAEyG,KAAKhH,GAAGA,EAAEiF,OAAO,SAAStF,GAAG,MAAOK,GAAEwE,OAAO3D,MAAMiE,IAAInF,IAAI2C,EAAEpB,EAAE4D,IAAInF,IAAIK,EAAE6N,WAAW,SAASlO,GAAG,GAAIC,GAAEI,EAAEwE,OAAO3D,MAAMuI,MAAO,OAAOxJ,IAAGD,EAAE2K,OAAO7J,OAAOS,EAAEoC,MAAMtD,EAAEwE,OAAO3D,MAAM0J,MAAMvK,EAAEwE,OAAO3D,MAAM0C,UAAUiH,WAAW5K,EAAED,EAAE2K,SAAS,MAAM9J,EAAEP,EAAEC,EAAEF,EAAEQ,GAAG,MAAOA,GAAEZ,EAAED,GAAGC,GAAGO,IAAI,SAASR,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,IAAKrB,EAAEiK,UAAU,WAAW,GAAIlK,GAAE6C,UAAUjB,OAAO,OAAG,KAASiB,UAAU,GAAGA,UAAU,GAAG,MAAO,QAAOsL,KAAK,WAAW/N,KAAKgO,GAAG,SAAShO,KAAKiO,YAAYjO,KAAKkO,cAAcxN,OAAOW,KAAKrB,KAAK2K,MAAM3K,KAAKiO,cAAcA,WAAW,WAAW,GAAGjO,KAAK2K,KAAK,IAAI,GAAI9K,KAAKG,MAAK2K,KAAK/K,IAAII,KAAKkO,cAAcvM,QAAQ9B,KAAKG,KAAK2K,KAAK9K,GAAGG,KAAK2K,KAAK/K,GAAGC,QAAQ,SAASD,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,IAAKrB,EAAEsO,gBAAgB,SAASvO,GAAG,OAAOmO,KAAK,WAAW,GAAIlO,GAAEG,IAAK,IAAG,cAAeA,MAAK2K,KAAK,CAAC,GAAIzK,GAAEF,KAAK2K,KAAKyD,WAAWC,KAAKpO,EAAED,KAAKsO,QAAQnO,EAAE,WAAW,GAAIF,IAAGL,GAAG,WAAW,MAAOC,GAAE0O,QAAStO,KAAIA,EAAEuO,UAAUpD,IAAIlL,GAAGD,EAAEuO,UAAUpD,IAAIlL,EAAE,UAAU0D,WAAW,WAAW3D,EAAEuO,UAAUC,OAAOvO,EAAE,WAAW,MAAMO,GAAE,EAAGQ,EAAE,WAAW,IAAIR,EAAE,CAACA,GAAE,CAAG,IAAIN,IAAGP,GAAG,WAAW,MAAOC,GAAE0O,QAAS,KAAIpO,EAAE,MAAOF,GAAEI,KAAKR,EAAGM,GAAEuO,iBAAiB,gBAAgB,WAAWzO,EAAEI,KAAKR,KAAKM,EAAEqO,UAAUpD,IAAIlL,EAAE,aAAcF,MAAK2O,IAAI,QAAQxO,GAAGO,OAAOC,eAAeX,KAAK,WAAWkB,MAAMD,SAAS,SAASrB,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,IAAKrB,EAAEkK,cAAc,SAASnK,GAAG,GAAIC,GAAED,EAAEoK,UAAU9J,MAAE,KAASL,EAAE,QAAQA,EAAEI,EAAEL,EAAEqK,SAAS9J,EAAEP,EAAEgP,SAASnO,MAAE,KAASN,GAAGA,CAAE,QAAO4N,KAAK,WAAW,GAAInO,IAAE,EAAGC,EAAE,SAASA,GAAGI,IAAIQ,GAAGb,GAAGZ,OAAOmG,sBAAsB,WAAW,MAAOlF,GAAEJ,EAAE,WAAW,MAAOD,IAAE,MAAOA,GAAE,GAAIK,EAAEJ,IAAKG,MAAK2O,IAAI,QAAQ,WAAWE,SAASH,iBAAiBxO,EAAEL,KAAKG,KAAK2O,IAAI,UAAU,WAAWE,SAASC,oBAAoB5O,EAAEL,SAAS,SAASD,EAAEC,EAAEK,GAAGA,EAAE,GAAG0J,KAAK,eAAe,ujDAAujD,GAAG,GAAG,SAAShK,GAAG,YAAa,IAAIC,GAAEG,KAAKC,EAAEC,EAAE,GAAGC,EAAED,EAAE,EAAGF,MAAK6J,OAAM,EAAG1J,EAAE2J,cAAc9J,KAAK0F,YAAY1F,KAAK+O,SAAS,WAAW,MAAOlP,GAAE8K,KAAKmC,SAASjN,EAAE8K,KAAKH,MAAM9I,OAAO,SAAS9B,GAAG,MAAOC,GAAE8K,KAAKqE,cAAcC,IAAIrP,KAAKC,EAAE8K,KAAKH,OAAOxK,KAAKkP,cAAc,SAAStP,GAAG,GAAIM,GAAEN,EAAEC,EAAE8K,KAAKnH,SAAU,OAAO3D,GAAEsP,KAAK7J,QAAQ1F,KAAKC,EAAEsP,KAAKtC,SAASjN,IAAIC,EAAEsP,KAAK/B,QAAQzL,QAAQ/B,GAAG,GAAGC,EAAEsP,KAAK9B,cAAczN,GAAGC,EAAEsP,KAAK7J,QAAQ1F,KAAKM,EAAEL,EAAE8K,KAAKyE,KAAKlP,EAAEkP,KAAKvP,EAAE8K,KAAKyE,MAAMlP,GAAGA,GAAGF,KAAKqP,iBAAiB,SAASzP,GAAG,MAAOC,GAAE8K,KAAKmC,SAASjN,EAAE8K,KAAKqE,cAAclO,IAAIlB,GAAG,MAAMI,KAAKsP,aAAa,SAAS1P,GAAG,SAAS6D,OAAO5D,EAAE8K,KAAKtH,WAAWzD,IAAK,IAAIa,GAAE,WAAWZ,EAAE8K,KAAK1E,SAASpG,EAAE8K,KAAKC,SAAU5K,MAAKgO,GAAG,SAASvN,GAAGA,IAAIT,KAAKyE,QAAQ3D,IAAI,WAAW,MAAOjB,GAAE8K,OAAO3K,KAAKyF,OAAO3E,IAAI,WAAW,MAAOjB,IAAG8F,IAAI,SAAS/F,GAAG,IAAI,GAAIM,KAAKN,GAAEM,IAAKL,KAAIA,EAAEK,GAAGN,EAAEM,MAAMF,KAAKmP,KAAK,GAAIlP,GAAEsP,SAASvP,KAAKyE,OAAO,KAAKzE,KAAKyF,MAAMzF,KAAK8K,QAAQ9K,KAAKwP,WAAWxP,KAAKmP,KAAKxB,mBAAmB,SAAS/N,EAAEC,EAAEK,GAAG,YAAaQ,QAAOC,eAAed,EAAE,cAAcqB,OAAM,GAAK,IAAIjB,GAAEC,EAAE,GAAGC,EAAE,SAASP,GAAG,MAAOA,IAAGA,EAAEd,WAAWc,GAAGb,QAAQa,IAAIK,GAAGQ,EAAEP,EAAE,EAAGL,GAAEd,QAAQoB,EAAEpB,QAAQ0Q,IAAI,mBAAkB,EAAG,SAAS7P,GAAG,GAAIC,GAAEG,IAAKA,MAAK6J,OAAM,EAAGpJ,EAAE0N,mBAAoB,IAAIjO,GAAE,WAAW,IAAI,GAAIN,KAAKC,GAAE6P,OAAO7P,EAAE6P,OAAO3O,eAAenB,KAAKC,EAAED,GAAGC,EAAE6P,OAAO9P,IAAKM,KAAIF,KAAKgO,GAAG,SAAS9N,YFwwBj7zBG,KAAK5B,EAASC,EAAoB,KAAKF,KAI9DmR,IACA,SAAUnR,EAAQC,GG7wBxBD,EAAAC,QAAA,SAAAD,GAoBA,MAnBAA,GAAAoR,kBACApR,EAAAqR,UAAA,aACArR,EAAAsR,SAEAtR,EAAAuR,WAAAvR,EAAAuR,aACArP,OAAAC,eAAAnC,EAAA,UACAqC,YAAA,EACAC,IAAA,WACA,MAAAtC,GAAA4B,KAGAM,OAAAC,eAAAnC,EAAA,MACAqC,YAAA,EACAC,IAAA,WACA,MAAAtC,GAAA2B,KAGA3B,EAAAoR,gBAAA,GAEApR,IHqxBMwR,IACA,SAAUxR,EAAQC,EAASC,GAEjC,YI5yBAA,GAAA,KACAA,EAAA,MJozBMuR,IACA,SAAUzR,EAAQC,EAASC,GKrzBjCA,EAAA,IACAkL,KAAA,s9BAAAe,GACA,YAEAjM,GAAA,QLg0BMwR,IACA,SAAU1R,EAAQC,EAASC,GMr0BjCA,EAAA,IACAkL,KAAA,ibAA6a,eAAAe,GAC7a,YAsBA,SAAAwF,GAAAtR,GAAsC,MAAAA,MAAAC,WAAAD,GAAuCE,QAAAF,GApB7E,GAAAuR,GAAA1P,OAAA8B,QAAA,SAAAgD,GAAmD,OAAArF,GAAA,EAAgBA,EAAAsC,UAAAjB,OAAsBrB,IAAA,CAAO,GAAAkQ,GAAA5N,UAAAtC,EAA2B,QAAAuM,KAAA2D,GAA0B3P,OAAAf,UAAAoB,eAAAV,KAAAgQ,EAAA3D,KAAyDlH,EAAAkH,GAAA2D,EAAA3D,IAAiC,MAAAlH,IAE/O8K,EAAAtQ,KAIAuQ,EAAA7R,EAAA,IAEA8R,EAAA9R,EAAA,IAEAC,EAAAD,EAAA,IAEAE,EAAAuR,EAAAxR,GAEA8R,EAAA/R,EAAA,KAEAgS,EAAAP,EAAAM,EAEA/R,GAAA,KAIAsB,KAAA2Q,UAAA,GAAAC,OACA5Q,KAAA2Q,UAAAE,IAAA,2BAEAjS,EAAAG,QAAA0Q,IAAA,8CAEAzP,KAAA8Q,SACAC,OAAA,kIAEAvG,MAAAkG,EAAA3R,QAEAyE,SAAA,QACAd,aAEAkI,SAAA,SAAA1G,GACAoM,EAAAQ,QAAApO,UAAAwB,EACAoM,EAAAxF,UAGAkG,WAAA,SAAA1H,GACA,uBAGA8F,KAAA,SAAAjO,EAAAgB,GACA,MAAAhB,GAAA8P,MAAAC,cAAA/O,EAAA8O,QAGA5H,OAAA,SAAA8H,GACA,gBAAAhR,GACA,SAAAoQ,EAAAa,QAAAjR,EAAA8Q,OAAAjP,SAAAmP,KAGA5H,YAEA7G,WAAA,aAEA+G,MAAA,mBAGA1E,KAAU8D,SAAA,gBACVnE,UAAA0L,KAA0BI,EAAA9L,UAAAhC,UAAA,WAC1B,MAAA4N,GAAAQ,QAAAtG,OACK,SAAAlK,GACLgQ,EAAAQ,QAAAtG,MAAAlK,EAAgCgQ,EAAAxF,YAGhCjI,KAAA,SAAAwO,EAAAC,GACAA,EAAAxO,aAAAyO,aAAAjB,EAAAK,UAAA,KACAW,EAAAxO,aAAAC,QAAA,mBAAAC,KAAAC,UAAAqN,EAAAQ,QAAApO,aAGAE,UAAA,SAAAyO,GACA,OAAAA,KAAAnN,OAAAmN,EAAAnN,gBAAA9B,UAGAgM,YACAC,KAAA,2BAGArO,KAAAwR,gBAAA,SAAAlI,GACA,gBAAAgI,GACAhB,EAAAQ,QAAApO,UAAA4N,EAAAQ,QAAApO,UAAAhB,OAAA,SAAA2P,GACA,MAAAA,KAAA/H,SNm1BMmI,IACA,SAAUjT,EAAQC,KAMlBiT,GACA,SAAUlT,EAAQC,EAASC;COl7BjC,SAAAiT,EAAAC,GACAA,EAAAnT,IAGCuB,EAAA,SAAAvB,GAA4B,YAmC7B,SAAAoT,GAAA3Q,GACA,MAAA4Q,IAAAC,KAAA7Q,GAQA,QAAA8Q,GAAA9Q,GACA,aAAAA,KAAA+Q,GASA,QAAAC,GAAAhR,GACA,MAAAA,eAAAiR,GAQA,QAAAC,GAAAlR,GACA,aAAAA,KAAAmR,GAQA,QAAAC,GAAApR,GACA,aAAAA,KAAAqR,GAQA,QAAAC,GAAAtR,GACA,MAAAkR,GAAAlR,IAAA,OAAAA,GAAA,KAAAA,EAQA,QAAAmB,GAAAnB,GACA,MAAAkB,OAAAC,QAAAnB,gBAAAkB,OASA,QAAAqQ,GAAA5T,EAAA6N,GACA,GAAAgG,GAAAhS,OAAAiS,yBAAA9T,EAAA6N,EACA,OAAA0F,GAAAvT,EAAA6N,KAAAgG,KAAA3G,SAqBA,QAAA6G,GAAAC,EAAAC,GACA,MAAA1Q,OAAAzC,UAAAwH,MAAA9G,MAAAyS,GAAAjE,UAAAkE,iBAAAF,IASA,QAAAG,GAAAH,EAAAC,GACA,OAAAA,GAAAjE,UAAAoE,cAAAJ,GAOA,QAAAK,KACA,MAAArE,UAAAsE,yBAOA,QAAAC,KACA,MAAAvE,UAAAwE,eAAA,IAQA,QAAAC,GAAAC,GACA,QAAAA,EAAAC,gBASA,QAAAC,GAAApF,GACA,cAAAA,EAAAQ,SAAA6E,gBAAAC,GAAAtF,GAAAQ,SAAA+E,cAAAvF,GASA,QAAAwF,GAAAC,EAAAC,GACA,GAAA3B,EAAA0B,EAAAE,WAGA,CACA,GAAAC,IAAA,GAAAC,YAAAC,gBAAAJ,EAAA,mBACA5E,EAAA2E,EAAAM,cAAAC,WAAAJ,EAAAK,iBAAA,EACAR,GAAAS,YAAApF,OALK2E,GAAAE,UAAAD,EAeL,QAAAS,GAAAC,EAAAC,GACAD,EAAAE,MAAAjL,QAAAgL,EAAA,UACAD,EAAA,QAAAC,EAQA,QAAAE,GAAAH,EAAApG,GACAoG,EAAAI,gBAAAxG,GAUA,QAAAyG,GAAAH,GACA,MAAAjU,QAAAW,KAAAsT,GAAA5S,OAAA,SAAAgT,EAAAC,GACA,MAAAD,GAAA,IAAAC,EAAA,KAAAL,EAAAK,GAAA,KACG,IASH,QAAAC,GAAAR,EAAApG,GACA,MAAAoG,GAAAS,aAAA7G,GASA,QAAA8G,GAAAV,EAAApG,EAAA+G,GACA,GAAAC,GAAAC,GAAAC,KAAAlH,EACAgH,MAAA,GACKZ,EAAAe,eAAAC,GAAAJ,EAAA,GAAAD,GAEAX,EAAAiB,aAAArH,EAAA+G,GASL,QAAAO,GAAApH,EAAAqH,EAAAxP,GACAmI,EAAAsH,aAAAD,EAAAxP,EAAA0P,YAAA1P,GAQA,QAAA2P,GAAAhC,EAAAiC,GACA,GAAAjC,EAEA,IADA,GAAAzT,GACAA,EAAA2V,GAAAV,KAAAxB,IACKiC,EAAA1V,EAAA,GAAA4V,cAAA5V,EAAA,IAAAA,EAAA,IAAAA,EAAA,IASL,QAAA6V,GAAA1B,EAAAuB,EAAAI,GACA,GAAA3B,EAAA,CACA,GACArO,GADAiQ,EAAAL,EAAAvB,EAAA2B,EAGA,SAAAC,EAAwB,MAIxB,KAFA5B,IAAA6B,WAEA7B,GACArO,EAAAqO,EAAA8B,YACAJ,EAAA1B,EAAAuB,EAAAK,GACA5B,EAAArO,GAgvBA,QAAAoQ,GAAAC,EAAAT,GAGA,IAFA,GAAAU,GAAAD,IAAAjV,OAAA,EACArB,EAAA,EACQA,EAAAuW,IAASvW,EACjB6V,EAAAS,EAAAtW,KAEA,OAAAsW,GASA,QAAAzU,GAAAoB,EAAAkG,GACA,WAAAlG,EAAAzB,QAAA2H,GAQA,QAAAqN,GAAAC,GACA,MAAAA,GAAAC,QAAA,kBAAAxF,EAAA9Q,GAAgD,MAAAA,GAAAuW,gBAShD,QAAA1K,GAAAwK,EAAA1V,GACA,MAAA0V,GAAAzP,MAAA,EAAAjG,EAAAM,UAAAN,EAWA,QAAAP,GAAA4S,EAAA7G,EAAAxL,EAAA4P,GAOA,MANApQ,QAAAC,eAAA4S,EAAA7G,EAAAqK,GACA7V,QACAL,YAAA,EACAkL,UAAA,EACAnL,cAAA,GACGkQ,IACHyC,EAaA,QAAAwD,GAAAlG,GAGA,OAFAhS,GACAmY,EAAAvU,UACAtC,EAAA,EAAiBA,EAAA6W,EAAAxV,SAAiBrB,EAClC,GAAAtB,EAAAmY,EAAA7W,GACA,OAAAuM,KAAA7N,GAEA4T,EAAA5B,EAAAnE,KACWmE,EAAAnE,GAAA7N,EAAA6N,GAIX,OAAAmE,GAwBA,QAAAoG,GAAAxC,EAAAyC,EAAAhX,GACA,GAAAiX,GAAAnX,KAAAoX,GAAA1H,OACApG,EAAAtJ,KAAAoX,GAAA9N,IAEA,KAAAA,EACK,KAAA6N,IAAA7N,GACLA,EAAA6N,EAAAC,GAAA9N,KACA6N,IAAAC,GAAA1H,MAgBA,IAXA+C,EAAAvS,EAAA,mBAAuCA,EAAA+E,cAAAwP,GAEvChC,EAAAvS,EAAA,YAAgCA,EAAAsF,OAAAtF,EAAAmX,YAEhC5E,EAAAvS,EAAA,WAA+BA,EAAAoX,MAAApX,EAAAqX,UAAArX,EAAAsX,SAE/BtX,EAAAoJ,OAEA4N,EAAA7W,KAAAL,KAAAE,GAGAuX,GAAAC,aAEAxX,EAAAyX,cAAA,CACA,GAAA3W,GAAA4W,GAAA5X,KAEAgB,GAAA6W,WAAsB7W,EAAA8J,UAWtB,QAAAgN,GAAAzJ,EAAA6I,EAAAzC,EAAAhF,GACA,GAAAsI,GACAC,EAAAf,EAAAhQ,KAAAwI,EAAAgF,EAAAyC,EAIAzC,GAAApG,GAAA,KAGA0J,EAAA1J,EAAAwI,QAAAoB,GAAA,IAGAjW,EAAAyN,EAAA2H,GAAAc,UAAAzD,IAAyChF,EAAA2H,GAAAc,UAAA5T,KAAAmQ,GACzCA,EAAA0D,MAA8B1D,EAAA0D,QAC9B1D,EAAA0D,IAAA9J,IAAmCoG,EAAA3F,oBAAAiJ,EAAAtD,EAAA0D,IAAA9J,IAEnCoG,EAAA0D,IAAA9J,GAAA2J,EACAvD,EAAA/F,iBAAAqJ,EAAAC,GAAA,GASA,QAAAI,GAAAC,EAAA3I,EAAA4I,GACA,GACAC,GADA9I,EAAA4I,EAAA5I,KAAA4I,EAAA5D,IAAA+D,KAGAC,EAAAhJ,IAAA2H,MACAsB,EAAAD,EAAAC,KACAC,EAAA,YAAAN,EAAA5D,IAAA6D,OAEA,IAAA7I,GAAA4I,EAAAC,YAEA,WADA7I,GAAA3E,QAKA2E,KAEAkJ,IACAJ,EAAAnF,IACAsF,EAAA5C,WAAAD,aAAA0C,EAAAG,IAGAjJ,EAAAnB,SAAA,IAIAgE,EAAAgG,KAEAD,EAAAO,KAAAC,GAAAP,GAGAD,EAAAO,OAEAP,EAAA5I,MAAAqJ,GACAT,EAAAO,MACArK,KAAA8J,EAAA5D,IACA/E,SACA4I,WAEAD,EAAA5D,IAAAT,UACAtE,GAGA8G,EAAA6B,EAAAU,MAAA,SAAA5X,GAAiC,MAAAgU,GAAA1F,EAAAlB,KAAApN,EAAAkN,KAAAlN,EAAAD,SACjCmX,EAAAC,UACA7I,EAAAvQ,QAGAyZ,GAAkBK,GAAAvJ,EAAA8I,GAAA9I,EAAAlB,MAGlBmB,EAAA0H,GAAA6B,UAAA,WACA,GAAAC,GAAAzJ,EAAA9E,KAAAwO,MACAC,IAAA3J,EAAAC,OAAA2J,KAAAH,EAAAzJ,GACA2J,GAAA3J,EAAA2H,GAAA1H,OAAA2J,KAAAH,EAAAzJ,GACAA,EAAAnB,aASA,QAAAgL,GAAAC,GACA,MAAAA,IACAA,IAAA1C,QAAA2C,GAAA,IACAC,GAAAF,KAA4CA,EAAAE,GAAAF,IAC5CA,GAHkB,KAYlB,QAAAG,GAAArB,GACA,IAAArY,KAAAuO,OAAA0G,EAAAjV,KAAAuO,KAAA,gBAEA,GASAoL,GACAC,EACA1Y,EAXAuT,EAAA4D,EAAA5D,IAEA8E,EAAAD,EAAAjB,EAAAwB,MACAC,EAAA9X,GAAA+X,GAAAC,IAAAT,GACAZ,EAAAN,EAAA9J,MAAA,YAAA8J,EAAA9J,KAAA+J,QACA5I,EAAA+E,IAAA4D,EAAA3I,QAAA+E,EAAAqB,YAEAmE,EAAA,UAAAV,EACAW,EAAA,UAAAX,CAMA,IAAAlB,EAAA8B,SAUA,YATA9B,EAAAjB,GAAAgD,WACA/B,EAAAvN,UAGAuN,EAAAnZ,QACAyZ,GACAK,GAAAX,IAAA9J,OAMA,IAAA8J,EAAAvN,OAAoB,MAAAuN,GAAAvN,QA0BpB,IAvBA5J,EAAAmZ,GAAAhC,OAAAyB,EAAA/C,KAA8CrW,OAAA6L,OAAAvM,KAAA0P,QAAA1P,YAC9C2Z,GAAAnH,EAAAtR,GACA0Y,EAAA1H,EAAAhR,GAGA0Y,IACAA,GAAAM,IAAAD,EACAC,EACAhZ,EAAAmZ,GAAArX,KAAAC,UAAA/B,GAAAlB,MACKia,IACL/Y,EAAA4T,EAAA5T,MAKAmX,EAAAwB,MAAAxB,EAAAiC,eAAAX,IAAA,IAAAzY,IACA0T,EAAAH,EAAA4D,EAAAwB,MACAxB,EAAAiC,eAAA,GAKAjC,EAAAkC,OAAkBrZ,OAAAqY,GAClBlB,EAAAmC,OAAoB,MAAApC,GAAAC,EAAArY,KAAAkB,EACpB,MAAAmX,EAAAoC,eAAApC,EAAAnX,aAGAmX,EAAAnX,QACAmX,EAAAoC,eAAA,GAGAb,GAAAE,GAAA,CAKA,GAHAtH,EAAAtR,KAAuBA,EAAA,KAGvBqY,EAeA,MAZArY,IAAA,QAEAwO,IAGA2I,EAAA3I,SACA,aAAAA,EAAA4I,SACA5I,EAAAxO,QACAwZ,KAA0BjG,EAAAkG,UAAAzZ,IAEduT,EAAAkG,UAAAzZ,GAOZ8Q,GAAA9Q,GACA4W,EAAAyB,EAAArY,EAAAuT,EAAAzU,MAEG8Z,EACHtF,EAAAC,EAAA8E,IAAAS,IAAA9Y,MAGAmX,EAAAkC,OACA9F,EAAA8E,GAAArY,GAGA,UAAAqY,GAAA9E,EAAAvT,YACAuT,EAAAvT,SAGAyY,IAAA,IAAAzY,GACAiU,EAAAV,EAAA8E,EAAArY,GAKA+Y,GAAAxF,EAAAmG,QAAoCpG,EAAAC,GAAA,MASpC,QAAAoG,GAAAC,GACAtE,EAAAsE,EAAApB,EAAAzS,KAAAjH,OAyGA,QAAA+a,GAAA1C,EAAA3L,EAAA0I,EAAA4F,GACA,GAAA1R,GAAA0R,EAAAta,OAAA6L,OAAAyO,KAGA,OAFA1R,GAAA+O,EAAA3L,OACA2L,EAAA4C,MAAiB3R,EAAA+O,EAAA4C,KAAA7F,GACjB9L,EAQA,QAAA4R,GAAAhX,EAAAmV,GAIA,IAHA,GAAAlZ,GAAAkZ,EAAA7X,OACAmG,EAAAzD,EAAA1C,OAEArB,EAAAwH,GACAxH,IACAsO,EAAA1O,MAAAsZ,EAAAlZ,IAAAkZ,EAAAlZ,IAWA,QAAAsO,GAAA4K,EAAAlZ,GACAkZ,EAAA8B,OAAAhb,EAAA,GACAH,KAAAsO,UACA8K,GAAApZ,KAAA0P,OAAA1P,UAAAoX,GAAAkB,SAAA,GAQA,QAAA8C,GAAAjb,GACA,GAAAkb,GAAArb,IAEAwW,GAAA9V,OAAAW,KAAArB,KAAAqZ,MAAA,SAAAf,GACAgD,GAAAvb,MAAAsb,EAAAhC,KAAAf,MAAAnY,MAWA,QAAAob,GAAAhN,EAAAiN,EAAA7C,GACAA,EACK8C,GAAA1b,MAAAC,MAAAuO,EAAAiN,IAEA7F,EAAApH,EAAAvO,KAAAuO,KAAAiN,EAAAjN,MAUL,QAAAmN,GAAAnN,EAAAiN,EAAA7C,GACAA,EACKgD,GAAA5b,MAAAC,MAAAuO,EAAAiN,IAEA7F,EAAApH,EAAAvO,KAAAuO,KAAAiN,EAAAjN,MASL,QAAAqN,GAAArN,EAAAoK,GACAA,EACKgD,GAAAtb,KAAAL,KAAAuO,GAEAA,EAAAgG,YAAAvU,KAAAuO,MAUL,QAAAsN,GAAApH,EAAA/E,EAAA2I,GACA,GAYAyD,GAZAC,QAAA9G,GAAAR,EAAAuH,MAAAzJ,IAAAqC,EAAAH,EAAAuH,IACA1D,EAAA2D,GAAAxH,GACAmE,EAAAC,GAAAP,GACAxC,EAAArB,EAAAqB,WACAoG,EAAA9I,IACA+I,EAAAC,GAAA3H,GACA4H,EAAApH,EAAAR,EAAA6H,IACAjD,KAEAkD,GAAA1D,GAAAP,GACAK,EAAA,YAAAlE,EAAA6D,QACAkE,IA4HA,OAxHA5H,GAAAH,EAAAgI,IAGApE,EAAAgC,GAAAqC,SAAArE,GACAA,EAAAsE,QAAA,EAEAN,GAAezH,EAAAH,EAAA6H,IAGfxG,EAAAD,aAAAqG,EAAAzH,GACAqB,EAAA8G,YAAAnI,GAEA4D,EAAAvN,OAAA,WAEAuN,EAAAnX,MAAAmZ,GAAAhC,EAAAjD,IAAA1F,EAEA,IAAAxL,GAAAmU,EAAAnX,MACA2b,EAAA3J,IACA4J,GAAAza,EAAA6B,KAAAoO,EAAApO,GACAqK,EAAA2N,EAAApG,UAIAvH,KAGAuO,GACAhB,EAAA5X,IAAA,EACAA,EAAA4X,EACApb,OAAAW,KAAA6C,GAAA+G,IAAA,SAAAyB,GAA+C,MAAAqO,GAAA1C,EAAAnU,EAAAwI,YAE/CoP,GAAA,EAGAO,IACAnY,IAAAxC,OAAA,SAAA4H,EAAAnJ,GACA,MAAAkY,GAAA3L,MAAAoQ,IACWzC,GAAAgC,EAAAtB,EAAA1C,EAAA/O,EAAAnJ,EAAAuP,MAEX2K,GAAAgC,EAAAtF,EAAArW,OAAA6L,OAAAmD,GAAApG,OAKAkN,EAAAtS,EAAA,SAAAoF,EAAAnJ,GAEA,GAAA4c,GAAAhB,SAAAzS,KAAA6I,KAAA2J,EACAkB,EAAAR,EAAA7a,QAAA2H,GACA2T,GAAA,IAAAD,EACA/B,GAAAgC,GAAAF,EAAAC,EAAA7c,EAEAsP,EAAA4J,EAAA4B,GACAiC,EAAA/c,GAAAqc,EAAAhb,OACA2b,EAAAJ,GAAAE,IAAAF,IAAAtN,CAEAnG,IAAAwS,GAAAzD,EAAA3L,IAAAqO,EAAA1C,EAAA/O,EAAAnJ,GAAAmJ,EAGA6T,GACA1N,EAAA,GAAA2N,IAAAxE,GACAlJ,SACAiN,QApEA,EAqEAJ,cACAjE,UACA/J,KAAAkG,EAAA4I,UAAAd,GACAjT,OACAgU,MAAAnd,GACSsU,EAAAT,WAGTvE,EAAAvQ,QAEAge,EACWtB,EAAA7b,MAAA0P,GAAAoN,GAAAtO,EAAAoK,IAEA+C,EAAA3b,MAAA0P,GAAAlB,EAAA8K,EAAAlZ,GAAAwY,IAEXuE,GAA0BV,EAAArB,OAAAhb,EAAA,EAAAmJ,GAC1B+P,EAAA8B,OAAAhb,EAAA,EAAAsP,GACA0M,GAAoBoB,GAAA7N,EAAA2J,KAAAf,EAAA7I,GAAA,IACbwL,IAAA9a,GAAA4c,IAEP/a,EAAAkC,EAAAsY,EAAAvB,MACAM,EAAAxb,MAAA0P,GAAAlB,EAAA8K,EAAAlZ,GAAAwY,IAEAU,EAAA8B,OAAAhb,EAAA,EAAAkZ,EAAA8B,OAAAF,EAAA,OAEAuB,EAAArB,OAAAhb,EAAA,EAAAqc,EAAArB,OAAAF,EAAA,QAIA5C,EAAA4C,MAAuBxL,EAAA4I,EAAA4C,KAAA9a,IAIvBgc,GAAA1M,EAAA4J,MAAiC+B,EAAA/a,KAAAoP,EAAAtP,IAKjCsP,EAAA2H,GAAA9N,OACAmG,EAAA2H,GAAAkG,MAAAnd,EACAsP,EAAA2H,GAAA1H,SAEAyN,GAAwB1N,EAAA3E,OAAAxB,KAIxB4R,EAAAhX,EAAAmV,GAGAmD,EAAAtY,EAAAiD,QAEAoH,EAAAsH,aAAAgH,EAAAX,KAGA7D,EAAA/J,QAAA,WACAkI,EAAA6C,EAAA,SAAAzZ,GAA6BA,EAAA0O,aAG7B+J,EAWA,QAAAmF,GAAAjP,EAAAuM,EAAA2C,GACA,GAAApC,GAAArb,KAEAuD,GAAcmM,QAASK,SAAA+K,GAEvB3E,GAAA5H,EAAA,SAAAkG,EAAA3B,GACA,GAEA+G,GACAxB,EACAqF,EAJAC,EAAAlJ,EAAAmJ,SACAlO,EAAAoD,EAAApD,MAKA,KAAA+N,GAAAhJ,IAAAlG,EAA2C,OAASmB,SAMpD,IAHA,IAAAiO,GAAA,UAAAlJ,EAAAqB,WAAAwC,SAAA+B,GAAAwD,QAAApJ,EAAAkG,YACOjL,EAAAK,SAAAzL,MAAuBmQ,MAAA4D,KAAA5D,EAAAkG,YAE9B,IAAAgD,EAAqB,MAAA7K,EAErB,IAAA6F,GAAA,YAAAlE,EAAA6D,OAGA,IAAAuB,EAAA5E,EAAAR,EAAAgI,IAGA,MAFA9D,IAAqBxD,EAAAV,EAAA,kBACrB/E,EAAAK,SAAAzL,KAAAuX,EAAApH,EAAA4G,EAAAxB,KACA,CAKA,IAAAA,EAAA5E,EAAAR,EAAA6H,IAEA,MADA5M,GAAAK,SAAAzL,KAAA5D,OAAA6L,OAAAuR,IAAA/P,KAAA0G,EAAA4G,EAAAxB,KACA,CAGA,KAAAxB,EAAApD,EAAAR,EAAAsJ,MACA1D,GAAAwD,QAAAxF,GAOA,MANA3I,GAAAK,SAAAzL,MACAkW,QAAA,EACAnC,OACA5D,MACAsE,SAAA5R,MAAA9G,KAAAoU,EAAAuJ,eAEA,CAaA,IAPAN,EAAAtB,GAAA3H,GACAkE,IACA1D,EAAAR,EAAA,gBAAuCA,EAAAwJ,cAAArB,YAAAnI,GACvCiJ,GAAAzI,EAAAR,EAAA,gBAAAQ,EAAAR,EAAA,iBACSiJ,GAAYrD,KAAA5F,EAAAyJ,aAGrBR,IAAAjJ,IAAAlG,GAAAkP,GAAA,CACA,IAAA9E,GAAA1D,EAAAR,EAAAsJ,IAsBA,MAXArO,GAAAK,SAAAzL,KACAwU,GACA4E,GAEAnP,KAAAkG,EACA/E,OAAA2L,GAEA5G,EAAAT,UACAqH,KAGA,CAnBAlG,GAAAV,EAAA,iBACA,IAAAhF,GAAA,GAAA2N,KACW/C,KAAA5F,EAAAyJ,YACA3P,KAAAkG,EAAA/E,OAAA2L,GACX5G,EAAAT,UAEAtE,GAAAK,SAAAzL,KAAAmL,GAyBA,MAPA0O,GAAApe,MAAAsb,GAAA5G,IAAAuJ,WAAA,SAAAnE,EAAAxB,GACAA,GACA3I,EAAAK,SAAAzL,KAAA+T,OAKY3I,WACTnM,GAWH,QAAA4a,GAAA1J,EAAAsE,EAAA/C,GACA,GAAAqF,GAAArb,IAEAwW,GAAAuC,EAAA,SAAAc,GACA,IAAAA,EAAgB,QAEhB,IAEAxB,GAFAhK,EAAAwL,EAAAxL,KACAkM,EAAA1I,EAAAxD,EAGArM,GAAAoc,GAAA/P,GACAgK,EAAA3X,OAAA6L,OAAA8R,IAAAtQ,KAAA0G,EAAA4G,EAAAhN,EAAAwL,EAAA3Y,OACKmZ,GAAAwD,QAAAhE,EAAA3Y,SACLmX,GAAc5D,MAAA4D,KAAAwB,EAAA3Y,MAAA2Y,KAAAxL,EAAAkM,SAGdvE,EAAA6D,EAAAxB,KAwBA,QAAAiG,GAAA/K,EAAA8G,EAAA/B,GAEA,GACAiG,GAAA,MAAAjG,EAAA,GACA5I,EAAA6O,EAAA,kBAUA,IANAhL,EAAAS,UAAA,IAAAtE,EAAA2K,EAAA9P,OAAA,KAAAmF,EACAA,EAAA6D,EAAA+C,WAKAiI,EACA7O,EAAA8O,eAAA,MACG,CAEH,GAAAC,GAAAC,GAAApG,EACAmG,IAAA,IAAA/O,EAAAiP,oBAAkDjP,EAAAsD,EAAAyL,EAAA/O,IAElD,MAAAA,GAOA,QAAAkP,GAAAvE,EAAAtG,GAEA,IAAA8K,GAAA9M,KAAAsI,GAA+B,MAAAA,EAG/B,IAAAxJ,KAOA,OALAkD,QAAA8C,QAAAiI,GAAA,SAAAzN,EAAAkH,EAAAwG,GAEA,MADAlO,GAAA0H,GAAA1H,EAAA0H,IAAAwG,EACA,KACGxU,OAEH8P,EACAxD,QAAAmI,GAAA,SAAA3N,EAAAkH,EAAA0G,GACA,MAAApO,GAAA0H,IAAA0G,GAAA,KAEApI,QAAAqI,GAAA,SAAA7N,EAAA4N,GACA,MAAAlL,IAAAkL,GAAA,KAcA,QAAAE,GAAA9E,EAAAtG,EAAAqL,GACA,GAAA/T,GAAAgP,KAAAhP,MAAA,iBACAiN,EAAAjN,KAAA,GAAA6K,cACA3C,EAAAE,EAAA2L,EAAAC,GAAAC,GAWA,OARAjF,GAAAuE,EAAAvE,EAAAtG,GAGAwL,GAAAxN,KAAAuG,GACK/E,EAAA+K,EAAA/K,EAAA8G,EAAA/B,GAEAzE,EAAAN,EAAA8G,GAEL9G,EASA,QAAAiM,GAAAjM,EAAA5I,GAEA,GAAA4N,GAAAvY,KACAqO,EAAAkK,EAAAlK,KACAgM,EAAA9B,EAAA8B,KACAtV,EAAAwT,EAAAxT,IACAgU,EAAAR,EAAAQ,MACA0G,EAAAlH,EAAAkH,QAaA,OAXA5G,IAAAxK,KACAqR,EAAArR,EAAAgM,EAAAtV,EAAAgU,EAAA0G,GAEA5G,GAAAxK,GAAAsR,MAAA3f,KAAAN,aAIAkgB,GAAArM,EAAAlF,EAAA1D,EAAA3K,MAEA+E,GAAY8a,GAAAC,SAEZ9f,KAYA,QAAA0f,GAAArR,EAAAgM,EAAAtV,EAAAgU,EAAA/C,GAqBA,MApBAhE,GAAA+G,KACA/C,EAAA+C,EAEA,cAAAhH,KAAAhN,IACAgU,EAAAhU,EACAA,EAAA,IAEOgU,EAAA,IAGPhU,IACAiN,EAAAjN,GACOiR,EAAAjR,EAEA8a,GAAAzU,IAAArG,IAGPsJ,IAAA6H,cACA2C,GAAAxK,IAAsBA,OAAAgM,OAAAtB,QAAA/C,MAEtB3H,EAYA,QAAA0R,GAAA1R,EAAAgM,EAAAtV,EAAAgU,EAAA/C,GAKA,MAJAjR,IAAY8a,GAAAzU,IAAArG,EAAAsJ,GAEZwK,GAAAxK,IAAsBA,OAAAgM,OAAAtB,QAAA/C,MAEtB3H,EAUA,QAAA2R,GAAAnN,EAAAyF,EAAA3N,GAIA,QAAAsV,GAAA1R,GACA,GAAAA,EAAA+J,QAAA,CACA,GAAA7I,GAAAyQ,EAAAjL,EAAA1G,EAAAwP,GAGAzF,IAAA4H,IAAA5H,IACA4H,EAAA5H,EACAnD,EAAA5G,EAAAwP,GAAAzF,IAGA7I,EAAAmQ,GAAArR,EAAA2R,GAAA3R,EAAA+J,QAAApC,cAAAvL,GAEA8E,GACS4J,EAAA/U,KAAAmL,OACJlB,GAAA/M,QACEgV,EAAAjI,EAAA0R,GAlBP,GACAE,GAAAC,EADA/G,IA+CA,IAzBAwG,GAAAC,SAEA5N,EAAAoG,KACA3N,EAAA2N,EACAA,EAAA,GAIAhG,EAAAO,IACAA,EAAA,MAAAA,EAGAuN,EAAAC,KAEAxN,EAAAwN,GAAAxN,EAAAlH,MAAA,QAIAwU,EAAAtN,EAAAD,EAAAC,OAIKsN,EAAAtN,EAGL,MAAAyF,EAAA,CAIA,GAFAA,EAAA8H,GAAAC,KAEAF,EAAA7H,QACO6H,EAAAvN,EAAA0F,EAAA6H,OACP,CAEA,GAAAG,KAEA9J,GAAA2J,EAAA,SAAAI,GAAiC,MAAAD,GAAAhc,KAAAsO,EAAA0F,EAAAiI,MAEjCJ,EAAAG,EAGAhI,EAAA,EAKA,MAFA2H,GAAAE,GAEA9G,EAeA,QAAAmH,GAAAnS,EAAAoS,EAAArZ,GAEA,GAAA8K,EAAA7D,GAEA,WADAmS,GAAA,KAAAE,KAAA,KAAArS,GAAA,EAIA,IAAAsS,GAAAvZ,EAAAwZ,GAAAC,EAGA,KAAAJ,EAAA,CACA,GAAArO,EAAAuO,EAAAtS,IACO,SAAArC,OAAA,uBAAAqC,EAEP,OAAAsS,GAAAtS,GAIAsS,EAAAtS,GAAA2D,EAAAyO,GACA1J,EAAA0J,EAAA9gB,UAAAghB,EAAAtS,SAA2CoS,EAC3C1J,EAAA4J,EAAAtS,OAA4BoS,GAO5B,QAAAK,MACA,MAAAtK,GAAAuK,GAAA,SAAAtR,GAA4C,MAAAA,GAAA3E,WAG5C,QAAAkW,IAAA3S,GACAwK,GAAAxK,GAAA,KA8BA,QAAAJ,IAAA0O,EAAAjN,EAAA6M,EAAA5R,EAAAsW,GAIA,IAAAtE,IAAAJ,EAAA,CACA,GAAAzJ,IAAAyJ,GAAAI,EAAA3c,KAAA0P,GAAA1P,IAEAwW,GAAAyK,EAAA,SAAApH,GACAA,EAAAxB,MAAoBwC,EAAAxa,KAAAyS,GAAA+G,EAAAxB,OAEpB1N,EAAAgM,EAAAkD,EAAAxL,MAAAwI,QAAA2C,GAAA,KAAAK,EAAAxB,KAAAwB,EAAAxB,KAAAnX,MAAA2Y,EAAA3Y,SASA,QAAAggB,IAAAhgB,GACAP,EAAAX,KAAA,YAAAkB,GAWA,QAAAkc,IAAAxE,EAAAuI,EAAAnN,OACA,KAAA4E,cACA,KAAAuI,SAEA,IAeA1M,GAfA9J,EAAAoM,KAAsBoK,EAAAxW,MACtB+E,EAAAyR,EAAAzR,OACAiN,EAAAwE,EAAAxE,OACAJ,IAAA4E,EAAA5E,YACA6E,EAAA3J,GAAA4J,mBAAA9E,EACAjT,EAAA6X,EAAA7X,KACAgU,EAAA6D,EAAA7D,MACA2D,KACAK,KACAxG,KACAvM,EAAA4S,EAAA5S,KACA+J,EAAA6I,EAAA7I,SAAA2D,GAAA1N,GACAoK,EAAA,YAAAL,EACAiJ,GAAA5I,IAAAC,EAAAyB,KACAmH,IAIAJ,IAAuBK,GAAAzhB,MAEvB4Y,EAAAvK,MAAAE,EAAAiK,MAA+BjK,EAAAiK,KAAAlK,SAAA,GAG/B4S,GAAA7gB,KAAAL,MAAA,GAEAW,EAAAX,KAAA,MACAuc,cACA0E,YACAjN,YACAsE,UACAgF,QACAX,SACA4E,WAGArJ,aAEAwJ,SACAtH,YAAA,EACAuH,KAAA,KACAjJ,KAAA,KACAhJ,OAAA,KACApG,KAAA,OAKA3I,EAAAX,KAAA,aAAA4hB,IACAjhB,EAAAX,KAAA,OAAAuO,GACAwI,EAAA/W,MAAgB2K,QAAarB,GAE7B3I,EAAAX,KAAA,SAAA0P,GAAA,MACA/O,EAAAX,KAAA,WACAW,EAAAX,KAAA,WAEAuhB,GAAA5E,GAAAJ,EACA9H,EAAAlG,GAEAoK,IAAqBpK,EAAAyF,UAAA,IACrBS,EAAA0K,EAAAvG,EAAAyB,KAAArG,EAAAV,EAAA/E,KAQA5N,EAAAX,KAAA,kBAAA6hB,GACA,GAAAC,MACAC,EAAA/hB,KAAA6X,YAAAuJ,CAKA,OAHArK,GAAA/W,KAAA6hB,GACA5T,GAAAlO,MAAAC,MAAA2c,EAAAjN,EAAA6M,EAAAuF,EAAAb,IAGAc,GACA/hB,KAAA6X,WACA7F,EAAAhS,KAAAgiB,gBAAAhiB,KAAAgiB,aAAAH,EAAAC,GAEA9hB,MAIA2c,GAAAJ,GAAgC0F,GAAAliB,MAAAC,WAAA0P,OAAA8R,IAChCzK,EAAApM,EAAAmX,GACAC,GAAqB/hB,KAAAkiB,QAAA,SAAAL,GACrBhH,EAAAxa,KAAAL,KAAA8a,GACAiH,GAAqB/hB,KAAAkiB,QAAA,WAErBliB,OAEGiH,KAAAjH,OAMHW,EAAAX,KAAA,mBACA,GAAAqb,GAAArb,IA+CA,OA7CAwW,GAAA/T,UAAA,SAAAge,GACA,GAAA0B,GAAAtjB,EACAujB,KAGAC,GAAA,mBAEA5B,GAAAnO,EAAAmO,GAAAD,EAAAC,KAKA0B,EAFAnQ,EAAAyO,GAEA,GAAAA,GACcA,CAEd,IAAA6B,GAAA5hB,OAAAkM,eAAAuV,EAGA,IAAUC,IAAA3e,OAAA/C,OAAA6hB,oBAAA1jB,GAAAsjB,UACVtjB,EAAA6B,OAAAkM,eAAA/N,GAAAsjB,GAGA3L,GAAA4L,EAAA,SAAA1V,GAGA,IAAA1K,EAAAqgB,EAAA3V,GAAA,CAEA,GAAAgG,GAAAhS,OAAAiS,yBAAAwP,EAAAzV,IAAAhM,OAAAiS,yBAAA2P,EAAA5V,GACA8V,EAAA9P,MAAA5R,KAAA4R,EAAA/M,MAGA0V,EAAAta,eAAA2L,IAAA8V,EACA9hB,OAAAC,eAAA0a,EAAA3O,EAAAgG,GAEA2I,EAAA3O,GAAAsF,EAAAmQ,EAAAzV,IACAyV,EAAAzV,GAAAzF,KAAAoU,GACA8G,EAAAzV,MAMAyV,EAAApU,MACSoU,EAAApU,KAAA9G,KAAAoU,OAETrb,MACGiH,KAAAjH,OAMHW,EAAAX,KAAA,mBACA,GAAAqb,GAAArb,IAEAuO,GAAAiK,KAAAxY,KAGAme,EAAApe,MAAA2P,GAAAnB,IAAAyP,WAAA,SAAAnE,EAAAxB,IACAkE,GAAA8B,GAAAoE,cAAApK,KAAwDA,EAAA5I,IAAA4L,GACxDxB,EAAAxB,OACA4I,EAAA3c,KAAAuV,MAIAyH,KACAvL,EAAA6C,EAAAG,MAAA,SAAA2J,EAAApb,GAA2Cga,EAAAhd,MAAiB+J,KAAAqU,EAAAxhB,MAAAoG,MAC5D6W,EAAApe,MAAAC,MAAAuO,EAAA+S,EAAA,SAAAzH,EAAAxB,GACAA,EAAiByC,EAAAxW,KAAA+T,GACLlD,EAAA5G,EAAAsL,EAAAxL,KAAAwL,EAAA3Y,UAIZ+M,GAAAlO,MAAAC,MAAA2c,EAAAjN,EAAA6M,EAAA5R,EAAAsW,GAGA,IAAA0B,GAAAnC,EAAAoC,GAEA,IAAAD,IAAAvB,EACA,OAAAjhB,KAAAwiB,GACAA,EAAA5hB,eAAAZ,IACAkb,EAAAxR,MAAA8Y,EAAAxiB,GAcA,IATAyY,EAAA5C,IAAkB4C,EAAA5C,GAAA3V,KAAAL,KAAA2K,GAElByW,GAAyBphB,KAAAkiB,QAAA,gBAGzB1E,EAAAzd,MAAAC,MAAAyU,EAAAqG,EAAAyB,IAEAvc,KAAA8K,OAAAxB,IAEAiT,IAAAgF,EACA,KAAA9M,EAAA6B,YAA8B/H,EAAAgG,YAAAE,EAAA6B,WAM9B,IAHA3V,EAAAX,KAAA,OAAAuO,IAGA6S,GAAAphB,KAAA0P,OAAA,CACA,GAAA1O,GAAA4W,GAAA5X,KAAA0P,OACA1O,GAAA2N,IAAA3N,EAAA6W,UAAA,6BACAqJ,GAAA7gB,KAAAgb,GAAA,GACAA,EAAA6G,QAAA,eAIAhB,IAAA7gB,KAAAL,MAAA,GACAohB,GAA2BphB,KAAAkiB,QAAA,QAK3B,OAFAliB,MAAAoX,GAAAgD,YAAA,EAEApa,MAEGiH,KAAAjH,OAOHW,EAAAX,KAAA,mBAAA6iB,GACA,GAKA1L,GALAkE,EAAArb,KAEAuT,EAAAvT,KAAAuO,KACAvN,EAAAuS,EAAAuC,WACAgN,EAAA/B,GAAApf,QAAA3B,KAwEA,OArEAohB,IAAyBphB,KAAAkiB,QAAA,kBAGzBnM,EAAA6C,EAAAG,MAAA,SAAA1K,GACAjC,EAAAiC,EAAAmL,MACSnL,IAAAlH,MAAAqS,GAAAhY,SAEToT,EAAArG,EAAAF,KAIArO,KAAAoX,GAAAc,UAAA5W,QAAA,SAAAmT,GACA/T,OAAAW,KAAAoT,EAAA0D,KAAA7W,QAAA,SAAAyW,GACAtD,EAAA3F,oBAAAiJ,EAAAtD,EAAA0D,IAAAJ,SAKA,IAAA+K,GACO/B,GAAA5F,OAAA2H,EAAA,IAEP9hB,GAAA2X,KACAjJ,GACAyH,EAAAS,GAAAlI,GAEAiJ,EACAjY,OAAAW,KAAArB,KAAAqZ,MAAA/X,QAAA,SAAAgX,GACAc,GAAAjC,EAAAkC,KAAAf,EAAA+C,EAAAhC,KAAAf,OAGAc,GAAAjC,EAAAkC,KAAAf,EAAAtY,MAEA0P,IAAAyH,GACAiC,GAAA1J,EAAA2J,KAAAf,EAAAtY,QAKA6T,EAAAN,EAAA,IAGAvS,IAAA6hB,GAA+B7hB,EAAA4b,YAAArJ,IAG/BvT,KAAAoX,GAAAsK,OACAlL,EAAAxW,KAAAoX,GAAAsK,MAAA,SAAApa,GACAA,EAAAwO,YAA2BxO,EAAAwO,WAAA8G,YAAAtV,KAK3Byb,GAAAjI,GACAtE,EAAAyK,EAAA,SAAA9f,GAAkC,MAAAA,GAAAkX,MAAAlX,EAAAkX,KAAA/J,SAAAnN,EAAAkX,KAAA/J,YAGlCtO,KAAAoX,GAAA6B,WAA4BjZ,KAAAoX,GAAA6B,YAE5BmI,IAEAphB,KAAA6X,WAA4B7X,KAAAkiB,QAAA,SAC5BliB,KAAAkiB,QAAA,WACAliB,KAAAgjB,IAAA,MAGAriB,EAAAX,KAAA,gBACAA,KAAAoX,GAAAgD,YAAA,QAEApa,MAAAuO,KAAAiK,KAEAxY,MAEGiH,KAAAjH,OAQH,QAAAoc,IAAA3H,GACA,MAAAA,GAAA6D,SAAAO,GAAA5D,EAAAR,EAAAsJ,KACA9I,EAAAR,EAAAsJ,KAAAtJ,EAAA6D,QAAApC,eASA,QAAA+L,IAAAzc,EAAAgc,GACA,GAAAnG,GAAArb,IAEAwW,GAAA9V,OAAAW,KAAAmE,GAAA,SAAAkd,GAEA,GAAAO,GAAAjhB,EAAAwf,EAAAkB,IAEAtQ,EAAAiJ,EAAAqH,KAAAO,KAGAA,GAAsBzB,EAAAld,KAAAoe,GACtBrH,EAAAqH,GAAAld,EAAAkd,MAWA,QAAApH,IAAAhD,EAAA4K,GACA,GACA7J,GADA3J,EAAA1P,KAAA0P,MAGAA,KAEA2J,EAAA3J,EAAA2J,KAAAf,GAEAjW,EAAAgX,GACKA,EAAA8B,OAAA+H,EAAA,EAAA7J,EAAA8B,OAAA9B,EAAA1X,QAAA3B,MAAA,OACGud,GAAA7N,EAAA2J,KAAAf,EAAAtY,OAWR,QAAA8Y,IAAAqD,EAAAxR,EAAAqJ,EAAAtE,GACA,GAAAD,GAAA,GAAA2N,IAAAjB,EAAAxR,EAAAqJ,GACAsE,EAAA3N,EAAA2N,SAAA2D,GAAAtR,EAAA4D,MAAA,GACA4I,EAAAS,GAAAlI,EAeA,OAbA/O,GAAA8O,EAAA,SAAA0H,GAIA1H,EAAA2H,GAAA1H,SAGA6N,GAAApG,EAAAkC,KAAAf,EAAA7I,GAGA0H,IAAAzH,GACK6N,GAAA7N,EAAA2J,KAAAf,EAAA7I,GAELA,EAQA,QAAAmI,IAAAnI,GAEA,IADA,GAAA0H,GAAA1H,EACA0H,EAAAC,GAAAmF,aACApF,EAAAzH,QACAyH,IAAAzH,MAEA,OAAAyH,GAOA,QAAA4L,IAAAjI,GACAtE,EAAAsE,EAAA,SAAAzC,GACAA,YAAA+E,IAAgC/E,EAAA/J,SAAA,GAChC+J,EAAAC,QAA4BD,EAAA5I,IAAAnB,SAAA,GAC5B+J,EAAA/J,SAA4B+J,EAAA/J,YAU5B,QAAA2N,IAAAxH,EAAA0O,GACA,GAAAhH,GAAAC,GAAA3H,GACA2O,GAAAD,GAAAlO,EAAAR,EAAAsJ,GACA,OAAAqF,KAAA/I,GAAAwD,QAAAuF,GACAA,EAAAjH,IAAA9N,KAAAoG,EAAA6D,QAAApC,cAYA,QAAAqH,IAAA1e,EAAA6N,EAAAxL,EAAAmiB,EAAA/F,GACA,GAAAgG,GAAAzkB,EAAA6N,GACA6W,EAAAlhB,EAAAihB,GACAE,GAAApR,EAAAkL,EAEA,KAAAgG,OAAApiB,EAGA,IAAAoiB,GAAAD,EAA6BxkB,EAAA6N,IAAAxL,OAC7B,IAAAoiB,EAGA,GAAAC,EAAA,CACA,GAAAE,GAAAH,EAAA3hB,QAAAT,EAEA,IAAAuiB,IAAAnG,EAA+B,QAE/B,IAAAmG,GAA4BH,EAAAnI,OAAAsI,EAAA,GAE5BD,EACAF,EAAAnI,OAAAmC,EAAA,EAAApc,GAEAoiB,EAAAhf,KAAApD,OAEYrC,GAAA6N,IAAA4W,EAAApiB,OAfOrC,GAAA6N,GAAAxL,EA2BnB,QAAAkY,IAAAva,EAAA6N,EAAAxL,EAAAmiB,GACA,GAAAhhB,EAAAxD,EAAA6N,IAAA,CACA,GAAA4Q,GAAAze,EAAA6N,GAAA/K,QAAAT,IACA,IAAAoc,GAAuBze,EAAA6N,GAAAyO,OAAAmC,EAAA,GACvBze,EAAA6N,GAAAlL,OACA,IAAA3C,EAAA6N,GAAAlL,QAAA6hB,IAAqDxkB,EAAA6N,GAAA7N,EAAA6N,GAAA,UAD1B7N,GAAA6N,cAGtB7N,GAAA6N,GAWL,QAAAkT,IAAArR,EAAA+J,EAAA3N,EAAAmI,GACA,GAAA8F,GAAAC,GAAAP,GACAoL,EAAA7K,GAAAP,GAAAqH,MACAlQ,EAAAqD,IAAA4Q,EAAAhjB,OAAA6L,OAAAmX,EAAA/jB,eAEAqU,EAAAzF,EAAAoV,WAAApV,EAAAoV,YAAApV,EAAAyF,UACAmN,EAAApK,GAAqBxI,OAAA5D,SAA4B+E,OAAA/E,IAAA+E,OAAA,MAUjD,OARAkJ,IAAArK,GAAqB6O,GAAArd,MAAA0P,GAAAmJ,EAAAuI,EAAAnN,IAErBvE,KAAAvQ,QACAuQ,EAAAvQ,OAAA,GAEA8C,EAAA+e,GAAAtR,IAAuCsR,GAAAzc,KAAAmL,IAGvCA,EASA,QAAAuJ,IAAAvJ,EAAA8I,GACA,GAAAsE,GAAA3J,GACAyI,IAAAtb,KAAAoP,EAAAoN,GACAtE,EAAAzC,WAAA8N,aAAA/G,EAAAtE,GASA,QAAAoD,IAAA9K,EAAArL,GACA,GAKAqe,GACAtQ,EANA8H,EAAArb,KAEA0Y,EAAAtF,IACAuO,EAAAvO,IACAyJ,EAAA3J,GAUA,KANAlT,KAAAuO,KAAAsH,aAAA6C,EAAA1Y,KAAAuO,KAAA+H,YACAtW,KAAAuO,KAAAgG,YAAAoN,GAEA3hB,KAAAoX,GAAAsB,KAAAnF,EAAAmF,EACA1Y,KAAAoX,GAAAuK,OAEApO,GACAsQ,EAAAtQ,EAAAgD,YACAsG,EAAAtI,YAAAhB,GACA8H,EAAAjE,GAAAsK,MAAApd,KAAAiP,GACAA,EAAAsQ,CAGAre,GACKqL,EAAAgF,aAAAgH,EAAArX,EAAA4R,GAAAsB,MAEA7H,EAAA0D,YAAAsI,GASL,QAAApB,IAAA5K,EAAArL,GAMA,IALA,GAEAqe,GAFAxI,EAAArb,KAEAuT,EAAAvT,KAAAoX,GAAAsB,KACAmE,EAAA3J,IAEAK,GAIA,GAHAsQ,EAAAtQ,EAAAgD,YACAsG,EAAAtI,YAAAhB,IACAA,EAAAsQ,KACAxI,EAAAjE,GAAAuK,KAAA,CACA9E,EAAAtI,YAAAhB,GACA1C,EAAAgF,aAAAgH,EAAArX,EAAA4R,GAAAsB,KACA,QAUA,QAAA2H,IAAAhH,GAEA,IAAAA,EAAA,CACA,GAAAhY,GAAAX,OAAAW,KAAAwX,GACA,OAAAxX,GAAAgf,GAAAhf,GAGA,MAAAgY,GACA3X,OAAA,SAAA9B,GAA0B,gBAAAmS,KAAAnS,KAC1BmC,OAAA,SAAA0U,EAAA7W,GACA,GAAAyO,GAAAzO,EAAA2K,OAAA2L,aACA,OAAAO,GAAA,KAAAsH,GAAA,KAAA1P,EAAA,MACK,IA5wFL,GAmTAyV,IAEAC,GArTAhD,MACAlI,MACA+J,GAAA,iBACApJ,GAAA,QACA4E,IAAA,kBACAL,GAAA,UACAzB,GAAA,KACAG,GAAA,OACAT,GAAA,aACAjC,GAAA,OACAC,GAAA,OACA7B,GAAA,kBACA5F,GAAA,SACAJ,GAAA,SACAE,GAAA,YACAJ,GAAA,WACAwD,GAAA,+BACA9B,GAAA,6BACA2B,GAAA,eACA0O,SAAAhlB,UAAAqT,OAAAvS,GAAAd,OACAilB,GAAA,yEACAC,GAAA,wDACAjM,GAAA,MACAhC,GAAA,gDACAwD,IAAiC0K,QAAA,WACjCrS,GAAA,oQACA4I,GAA2C,GAA3CsJ,OAAAnV,cAA2CuV,aA8E3CC,GAAA3jB,OAAA4jB,QACAzS,aACAG,aACAE,WACAE,cACAE,WACAE,UACAnQ,UACAoQ,eAiLAgC,GAAA/T,OAAA4jB,QACA1R,KACAI,IACAE,aACAE,uBACAE,QACAG,OACAI,eACAW,mBACAI,UACAE,sBACAG,UACAE,UACAQ,aACAI,YACAI,cAMAoO,MACAC,MACAC,IAAA,CAGAT,MACAF,GAAA,WAEA,GAAAY,GAAAjR,EAAA,QACA0B,GAAAuP,EAAA,kBAGA,IAAAC,GAAA3R,EAAA,mBAQA,OANA2R,IACAA,EAAAC,KAAwBF,EAAAE,GAAAD,EAAAC,IACxBD,EAAA7O,WAAA8N,aAAAc,EAAAC,IAEU9V,SAAAgW,qBAAA,WAAAtQ,YAAAmQ,GAEVA,KAEAX,GAAAD,GAAAgB,WAMA,IAAAjF,KACAiE,aAMA1Y,IAAA,SAAArG,EAAAsJ,GACAA,EAAekW,GAAAlW,GAAAtJ,EACLyf,GAAAlgB,KAAAS,GACV0f,IAAA,GAMA3E,OAAA,WACA,GAAAkE,IAAAS,GAAA,CACAA,IAAA,CACA,IAAA9P,GAAAjU,OAAAW,KAAAkjB,IACAtZ,IAAA,SAAAyX,GAAyB,MAAA6B,IAAA7B,KACzBjf,OAAA+gB,IAAAhZ,KAAA,KAEAuY,IAAsBA,GAAAgB,QAAApQ,EACZmP,GAAA9P,UAAAW,KASVqQ,GAAA,WAyBA,QAAAC,GAAAC,EAAAjK,GACA,OAAAA,GAAA,QAAAlJ,KAAAmT,EAAAjK,MACA,MAAAA,GAGA,QAAAkK,GAAAD,EAAAE,GAEA,GAAAC,GAAA,MACApK,EAAAoK,EAAAte,UAAAqe,IACA/Z,EAAAga,EAAA9P,KAAA2P,GAAA,GAAA7Z,MAAAia,EAEA,IAAAja,EAAA,CACA,GAAAjF,GAAA6U,EAAA5P,EAAA,GAAA7J,MAEAyZ,GAAAgK,EAAAC,EAAAjK,EACA,IAAA1a,GAAA2kB,EAAAjK,EAEA,IAAAA,EAAA,IAAAsK,EAAA5jB,QAAApB,GACA,MAAA6F,EAGA,UAAA7F,EAEA,MAAA2kB,EAAAjK,EAAA,KACAmK,EAAAhf,OAGO,UAAA7F,GAAA,MAAAA,GAEP2kB,IAAAjK,KAAA1a,IACA0a,EAAAgK,EAAAC,EAAAjK,IAAA,IACAuK,EAAAzT,KAAAmT,EAAAjK,OACAmK,EAAAhf,OAGO,KAAAqf,EAAA9jB,QAAApB,GAAA,CAIP,IAFA,GAAAmlB,GAAAzK,EAAA,IAEAA,GAAA,GAAAuK,EAAAzT,KAAAmT,EAAAjK,OACA0K,EAAAhkB,QAAAujB,EAAA/d,MAAA8T,EAAA,EAAAyK,MACAN,EAAAhf,IAKA,MAAAgf,GArEA,GAAAG,GAAA,oBAEAI,GACA,OACA,UACA,KACA,OACA,KACA,aACA,SACA,SACA,SACA,OACA,SAGAF,EAAAE,EAAA5jB,OAAA,SAAAd,EAAA2G,GACA,MAAA3G,GAAA2G,EAAAT,OAAA,IACG,IAEHme,EAAA,gFACAE,EAAA,OAmDA,OAAAL,MAgBAS,GAAA,SAAAC,GA6CA,QAAAC,GAAAT,GAA2B,MAAAA,GAE3B,QAAAU,GAAAV,EAAAW,GAEA,MADAA,KAAcA,EAAAC,GACd,GAAA3a,QACA+Z,EAAAhV,OAAAwG,QAAA,KAA0BmP,EAAA,IAAAnP,QAAA,KAAqBmP,EAAA,IAAAX,EAAA1T,OAAAuU,EAAA,IAI/C,QAAAC,GAAAC,GACA,GAAAA,IAAAC,EAA2B,MAAAC,EAE3B,IAAAC,GAAAH,EAAAza,MAAA,IAEA,QAAA4a,EAAA/kB,QAAAglB,EAAAzU,KAAAqU,GACA,SAAApa,OAAA,yBAAAoa,EAAA,IASA,OAPAG,KAAA9iB,OAAA2iB,EAAAvP,QAAA4P,EAAA,MAAA9a,MAAA,MAEA4a,EAAA,GAAAR,EAAAQ,EAAA,GAAA/kB,OAAA,eAAqD8kB,EAAA,GAAAC,GACrDA,EAAA,GAAAR,EAAAK,EAAA5kB,OAAA,aAA+C8kB,EAAA,GAAAC,GAC/CA,EAAA,GAAAR,EAAAO,EAAA,GAAAC,GACAA,EAAA,GAAAjb,OAAA,QAAAib,EAAA,iBAA+CA,EAAA,QAAAG,EAAAR,GAC/CK,EAAA,GAAAH,EACAG,EAGA,QAAAI,GAAAC,GACA,MAAAA,aAAAtb,QAAAub,EAAAD,GAAAX,EAAAW,GAgHA,QAAAE,GAAAV,IACAA,MAAAC,MAAAJ,EAAA,KACAA,EAAAE,EAAAC,GACAS,EAAAT,IAAAC,EAAAP,EAAAC,EACAE,EAAA,GAAAY,EAAAP,EAAA,KAEAS,EAAAX,EAGA,QAAAY,GAAAvmB,GACA,GAAA0B,EAEA1B,SACA0B,EAAA1B,EAAAmlB,SACAllB,OAAAC,eAAAF,EAAA,YACAkF,IAAAmhB,EACAhmB,IAAA,WAAwB,MAAAimB,IACxBlmB,YAAA,IAEAomB,EAAAxmB,EACAqmB,EAAA3kB,GA3MA,GAuCA0kB,GAEAI,EAxCAf,EAAA,IAEAgB,EAAA,qCAEAC,EAAA,6FAEAC,EAAAD,EAAA9W,OAAA,IACA,wDAAAA,OAAA,IACA,kFAAAA,OAEAmW,EAAAlb,OAAA,qCAEAmb,EAAA,sBAEAC,EAAAS,EAAA9W,OAAA,oBAAAA,OAEAgX,GACAC,IAAAhc,OAAA,UAAAob,EAAAR,GACAqB,IAAAjc,OAAA,YAAAob,EAAAR,GACAsB,IAAQlc,OAAA,UAAeob,EAAAR,IAGvBG,EAAA,MAEAC,GACA,IAAM,IACN,IAAM,IACN,UACA,YACA,WACAhb,OAAA,uBAA8Bob,EAAAR,GAC9BG,EACA,yDACA,wBAIAU,MAxCA,GA0CAd,IAqLA,OAnJAU,GAAAhb,MAAA,SAAAiL,EAAAyD,EAAAoN,GAkEA,QAAAC,GAAAzmB,GACA0mB,IACA1mB,EAAA0mB,EAAA1mB,EACA0mB,EAAA,IAEAtN,GAAAuN,EACAC,EAAAvjB,KAAArD,KAAA4V,QAAA4Q,EAAA,UAEAI,EAAAvjB,KAAArD,GAIA,QAAA6mB,GAAAC,EAAAC,EAAAC,GAWA,MAVAA,KACAD,EAAAhD,GAAApO,EAAAmR,IAGA1N,GAAA2N,EAAAD,EAAA,IACAG,EAAA,IAAAC,EAAA3mB,OAAA,IACA2mB,EAAA7jB,KAAAsS,EAAAzP,MAAA4gB,EAAAC,IACAL,GAAA/Q,EAAAzP,MAAAie,EAAA2C,GAAAG,EACA9C,EAAA4C,GAEAA,EAvFAP,IAAeA,EAAAxB,EAEf,IAEA5a,GACAuc,EACAxC,EACAnK,EAKAiN,EAAAnhB,EATA8gB,KAKAxC,EAAAoC,EAAA,GAEAU,KACAR,EAAA,EAKA,KAFAC,EAAAxC,EAAAC,EAAAte,UAAA,EAEAsE,EAAAga,EAAA9P,KAAAqB,IAAA,CAKA,GAHA7P,EAAAse,EAAAte,UACAkU,EAAA5P,EAAAiS,MAEAsK,EAAA,CAEA,GAAAvc,EAAA,IAEA,GAAA+c,GAAA/c,EAAA,GACAgd,EAAAhB,EAAAe,GACAE,EAAA,CAGA,KADAD,EAAAthB,YACAsE,EAAAgd,EAAA9S,KAAAqB,IACA,GAAAvL,EAAA,IACA,GAAAA,EAAA,KAAA+c,IAAoCE,MACpC,OAAAA,EAA+B,UAE/BD,GAAAthB,UAAA+gB,EAAAzc,EAAAiS,MAAA+K,EAAAthB,UAAAsE,EAAA,GAGAga,GAAAte,UAAAuhB,EAAA1R,EAAApV,OAAA6mB,EAAAthB,SACA,UAGA,IAAAsE,EAAA,IACAga,EAAAte,UAAA+gB,EAAA7M,EAAAlU,EAAAsE,EAAA,GACA,WAIAA,EAAA,KACAqc,EAAA9Q,EAAAzP,MAAAie,EAAAnK,IACAmK,EAAAC,EAAAte,UACAse,EAAAoC,EAAA,GAAAG,GAAA,IACAvC,EAAAte,UAAAqe,GAUA,MANAxO,IAAAwO,EAAAxO,EAAApV,QACAkmB,EAAA9Q,EAAAzP,MAAAie,IAGAyC,EAAAM,UAEAN,GA6BAlB,EAAA9I,QAAA,SAAAjH,GACA,MAAAqP,GAAA,GAAAlU,KAAA6E,IAGA+P,EAAAjK,SAAA,SAAArE,GACA,GAAA/X,GAAA+X,EAAAhN,MAAA4a,EAAA,GAEA,OAAA3lB,IACSoM,IAAApM,EAAA,GAAA2a,IAAA3a,EAAA,GAAA8U,IAAA6Q,EAAA,GAAA3lB,EAAA,GAAAiK,OAAA0b,EAAA,KACA7Q,IAAAiD,EAAA9N,SAGToc,EAAAvjB,MAAA,SAAAgjB,GACA,MAAAA,GAAAD,EAAAC,GAAAH,GA0BAvlB,OAAAC,eAAAgmB,EAAA,YACAhhB,IAAAqhB,EACAlmB,IAAA,WAAsB,MAAAmmB,MAItBN,EAAA4B,SAAA,mBAAAC,YAAAD,aACA5B,EAAAhhB,IAAAmhB,EACAH,EAAA3B,aAEA2B,EAAAQ,YACAR,EAAAO,YACAP,EAAAS,YACAT,EAAAD,YAEAC,KAaAtM,GAAA,WAIA,QAAAoO,GAAA7R,EAAAiL,GACA,MAAAjL,IAEAqP,EAAArP,KAAAqP,EAAArP,GAAAuP,EAAAvP,KAAAvW,KACAwhB,EAAA6G,EAAAzhB,MACA4a,OACAxH,KAAAzD,KALeA,EAmBf,QAAA8R,GAAAC,EAAA7V,GAEA6V,EAAAC,UACAtQ,QAAAxF,KAAAsE,IAAAtE,EAAAsE,GAAAkB,QACA6B,SAAArH,KAAAqH,UAGAsO,EAAAI,aAA6BJ,EAAAI,aAAAF,GAE7B,mBAAA9c,UACA,kBAAAA,SAAAid,QAEAjd,QAAAid,MAAAH,EAAAI,SACAld,QAAAC,IAAA,UAAA6c,EAAAC,SAAAtQ,SAAA,cAAAtY,KAAAqa,MACAxO,QAAAC,IAAA9L,KAAA6hB,OAIA,QAAAsE,GAAAvP,GACA,GAAAyB,GAAA2Q,EAAApS,EAIA,OAFA,gBAAAyB,EAAAlR,MAAA,QAA8CkR,EAAA,UAAAA,GAE9C,GAAA4Q,UAAA,IAAA5Q,EAAA,KAMA,QAAA2Q,GAAApS,GACA,GAEAyB,GAFAwP,EAAAjC,GAAAja,MAAAiL,EAAAC,QAAAqS,EAAA,QACAC,EAAAtB,EAAAM,OAGA,IAAAN,EAAArmB,OAAA,GAAAqmB,EAAA,IACA,GAAA1nB,GAAAwH,EAAA8O,IAEA,KAAAtW,EAAAwH,EAAA,EAAqBxH,EAAA0nB,EAAArmB,SAAkBrB,GAEvCkY,EAAAwP,EAAA1nB,MAEAkY,EAAA,EAAAlY,EAEAipB,EAAA/Q,EAAA,EAAA8Q,GAEA,IAAA9Q,EACAxB,QAAA,cACAA,QAAA,mBACAA,QAAA,YACA,OAEcJ,EAAA9O,KAAA0Q,EAIdA,GAAA1Q,EAAA,EAAA8O,EAAA,GACA,IAAAA,EAAAjL,KAAA,sBAIA6M,GAAA+Q,EAAAvB,EAAA,KAAAsB,EAUA,OAPAA,GAAA3nB,SACA6W,IAAAxB,QAAAwS,EAAA,SAAAhY,EAAA4J,GACA,MAAAkO,GAAAlO,GACApE,QAAA,aACAA,QAAA,gBAGAwB,EAWA,QAAA+Q,GAAA/Q,EAAAiR,EAAAH,GAMA,GAJA9Q,IACAxB,QAAA,YAAAtM,OACAsM,QAAA,wBAA0B,MAE1B,CAMA,IALA,GAGAxL,GAFAoL,KACA8S,EAAA,EAGAlR,IACAhN,EAAAgN,EAAAhN,MAAAme,MACAne,EAAAiS,OACA,CACA,GACA5Q,GACA+c,EACApE,EAAA,cAKA,KAHAhN,EAAA/M,OAAAoe,aACAhd,EAAArB,EAAA,GAAA8d,EAAA9d,EAAA,IAAAlE,MAAA,MAAAoD,OAAAsM,QAAA,YAAAxL,EAAA,GAEAoe,GAAApe,EAAAga,EAAA9P,KAAA8C,IAAA,KAaA,SAAA+P,EAAA/C,GACA,GACAsE,GACAC,EAAA,EACAC,EAAAC,EAAA1B,EAGA,KADAyB,EAAA9iB,UAAAse,EAAAte,UACA4iB,EAAAE,EAAAtU,KAAA8C,IACA,GAAAsR,EAAA,KAAAvB,IAA2BwB,MAC3B,OAAAA,EAAyB,KAEzBvE,GAAAte,UAAA6iB,EAAAvR,EAAA7W,OAAAqoB,EAAA9iB,WAxBkD0iB,EAAApE,EAElDoE,GAAApR,EAAAlR,MAAA,EAAAkE,EAAAiS,OACAjF,EAAA/M,OAAAoe,aAEAjT,EAAA8S,KAAAQ,EAAAN,EAAA,EAAA/c,GAGA2L,EAAAkR,EACAA,EAAA,MAAA9S,EAAAjL,KAAA,0BAAAiL,EAAA,GADAsT,EAAA1R,EAAAiR,GAGA,MAAAjR,GAuBA,QAAA0R,GAAA1R,EAAAiR,EAAA5c,GACA,GAAAsd,EAiCA,OA/BA3R,KAAAxB,QAAAoT,EAAA,SAAA5e,EAAArK,EAAAkpB,EAAAjP,EAAAha,GAWA,MAVAipB,KACAjP,EAAA+O,EAAA,EAAA/O,EAAA5P,EAAA7J,OAEA,SAAA0oB,GAAA,WAAAA,GAAA,WAAAA,GACA7e,EAAArK,EAAA,KAAAkpB,EAAAC,EAAAD,EACAjP,IAAoB+O,EAAA,OAAA/oB,IAAAga,KAAA,MAAAha,GAAA,MAAAA,IACXga,IACT+O,GAAAI,EAAArY,KAAA9Q,EAAAkG,MAAA8T,MAGA5P,IAGA2e,IACA3R,EAAA,cAAkBA,EAAA,wBAGlB3L,EAEA2L,GAAA2R,EACA,cAAwB3R,EAAA,eAAa,IAAAA,EAAA,KACrC,KAAA3L,EAAA,OAEK4c,IAELjR,EAAA,gBAA0B2R,EAC1B3R,EAAAxB,QAAA,sBAAAwB,EAAA,KACA,qCAGAA,EAnMA,GAAA4N,KAaAwC,GAAA5K,QAAA+H,GAAA/H,QAEA4K,EAAA/L,SAAAkJ,GAAAlJ,SAGA+L,EAAA4B,WAAA,WAAkCpE,MAElCwC,EAAAI,aAAA,IA4BA,IAAAK,GAAA,UACAG,EAAA,gBA8CAG,EAAA,2DAEAM,GACAxC,IAAA,QACAC,IAAA,SACAC,IAAQ,SAyDR2C,EAAA,kCAAAnrB,QAAA,wBACAirB,EAAA,oKACAG,EAAA,+BAyCA,OAFA3B,GAAA6B,QAAA1E,GAAA0E,QAAA,SAEA7B,KAKAhH,GAAA,SAAAlO,GAOAA,OAKA,IAAAgX,MACApjB,EAAA/E,MAAAzC,UAAAwH,KA6GA,OAtGAzG,QAAA8pB,iBAAAjX,GAQAvF,IACA9M,MAAA,SAAAoQ,EAAA0E,GAGA,MAFA,kBAAAA,KACWuU,EAAAjZ,GAAAiZ,EAAAjZ,QAAAhN,KAAA0R,GACXzC,GAEA1S,YAAA,EACAkL,UAAA,EACAnL,cAAA,GASAoiB,KACA9hB,MAAA,SAAAoQ,EAAA0E,GACA,QAAA1E,GAAA0E,EAEA,GAAAA,EAEA,OAAAgC,GADAuO,EAAAgE,EAAAjZ,GACAnR,EAAA,EAA+B6X,EAAAuO,KAAApmB,KAAoBA,EACnD6X,GAAAhC,GAA6BuQ,EAAApL,OAAAhb,IAAA,cAEXoqB,GAAAjZ,OAPgBiZ,KASlC,OAAAhX,IAEA1S,YAAA,EACAkL,UAAA,EACAnL,cAAA,GAUA+N,KACAzN,MAAA,SAAAoQ,EAAA0E,GACA,QAAAhI,KACAuF,EAAAyP,IAAA1R,EAAAtD,GACAgI,EAAAjW,MAAAwT,EAAA9Q,WAEA,MAAA8Q,GAAAvF,GAAAsD,EAAAtD,IAEAnN,YAAA,EACAkL,UAAA,EACAnL,cAAA,GASAshB,SACAhhB,MAAA,SAAAoQ,GACA,GAMAmZ,GACAzU,EACA7V,EARAuqB,EAAAjoB,UAIAkoB,EAAAloB,UAAAjB,OAAA,EACAwV,EAAA,GAAA5U,OAAAuoB,EAKA,KAAAxqB,EAAA,EAAmBA,EAAAwqB,EAAYxqB,IAC/B6W,EAAA7W,GAAAuqB,EAAAvqB,EAAA,EAKA,KAFAsqB,EAAAtjB,EAAA9G,KAAAkqB,EAAAjZ,OAAA,GAEAnR,EAAA,EAAmB6V,EAAAyU,EAAAtqB,KAAaA,EAChC6V,EAAAjW,MAAAwT,EAAAyD,EAMA,OAHAuT,GAAA,WAAAjZ,GACWiC,EAAA2O,QAAAniB,MAAAwT,GAAA,IAAAjC,GAAA7N,OAAAuT,IAEXzD,GAEA1S,YAAA,EACAkL,UAAA,EACAnL,cAAA,KAIA2S,GA2FAqX,GAAAlqB,OAAA4jB,QACA9N,OACAxU,WACA2U,UACAvK,aACAzL,iBACAoW,WAGAU,GAAAV,EAAArW,OAAA6L,OAAAqZ,GAAA2C,WACAlH,mBAAA,EAEA3J,YAAA,IAiRAoG,IACA/P,KAAA,SAAA0G,EAAAhF,EAAA4I,GACAzD,EAAAH,EAAA6H,IACAtc,KAAAyP,MACAzP,KAAAqY,OACArY,KAAA6qB,KAAAzX,IACApT,KAAA8qB,SAAArW,CAEA,IAAAzT,GAAAyT,EAAAqB,UAIA,OAHA9U,GAAA6U,aAAA7V,KAAA6qB,KAAApW,GACAzT,EAAA4b,YAAAnI,GAEAzU,MAEA8K,OAAA,WACA9K,KAAAkB,MAAAmZ,GAAAra,KAAAqY,KAAArY,KAAAyP,KAEAzP,KAAAkB,QAAAlB,KAAA+qB,SACA/qB,KAAA+qB,QAAA/qB,KAAA8qB,SAAAzN,WAAA,GACArd,KAAA6qB,KAAA/U,WAAAD,aAAA7V,KAAA+qB,QAAA/qB,KAAA6qB,MACA7qB,KAAA8a,eACA0C,EAAAzd,MAAAC,KAAAyP,KAAAzP,KAAA+qB,QAAA/qB,KAAA8a,aAAA,MACK9a,KAAAkB,OAAAlB,KAAA+qB,UACLhI,GAAA/iB,KAAA8a,aACA9a,KAAA+qB,QAAAvS,KACAxY,KAAA+qB,QAAAvS,KAAAlK,UACOtO,KAAA+qB,QAAAjV,YACP9V,KAAA+qB,QAAAjV,WAAA8G,YAAA5c,KAAA+qB,SAEA/qB,KAAA+qB,QAAA,KACA/qB,KAAA8a,gBAGA9a,KAAAkB,OAAqB2Z,EAAAxa,KAAAL,KAAAyP,IAAAzP,KAAA8a,cAErBxM,QAAA,WACAyU,GAAA/iB,KAAA8a,mBAIAuD,IACAtQ,KAAA,SAAA0G,EAAA/E,EAAA6J,EAAAyR,GAMA,MALAhrB,MAAAyU,MACAzU,KAAA6Z,KAAAN,EACAvZ,KAAAirB,SAAAD,EACAhrB,KAAA0P,SACA1P,KAAAkrB,OAAA7Q,GAAAwD,QAAAmN,GACAhrB,MAEA8K,OAAA,WACA,GAAAqgB,GAAAnrB,KAAAkB,MACAkqB,EAAAprB,KAAA0P,QAAAkI,GAAA5X,KAAA0P,QAEA2b,EAAArrB,KAAAyU,IAAA6W,OAAAtrB,KAAAyP,KAAAzP,KAAAyU,GAEAzU,MAAAkB,MAAAlB,KAAAkrB,OAAA7Q,GAAAra,KAAAirB,SAAAjrB,KAAA0P,QAAA1P,KAAAirB,UAGAzY,EAAA2Y,IAAAC,GAAwChS,GAAAgS,EAAAG,KAAAJ,EAAAE,IACxC7Y,EAAAxS,KAAAkB,QAAAoR,EAAAtS,KAAAkB,QAEAkqB,GAAyB7N,GACzB6N,EAAAG,KACAvrB,KAAAkB,MACAmqB,EAEA,KACArrB,KAAA0P,OAAA0H,GAAAkG,OAGAtd,KAAAkB,QAAAiqB,GACAhW,EAAAnV,KAAAyU,IAAAzU,KAAA6Z,KAAA7Z,KAAAkB,QAGA0T,EAAA5U,KAAAyU,IAAAzU,KAAA6Z,MAKA7Z,KAAAyU,IAAA6W,QAA0BtrB,KAAAyU,IAAA6W,MAAAD,IAE1B/c,QAAA,WACA,GAAA+c,GAAArrB,KAAAyP,KAAAzP,KAAAyU,IACA2W,EAAAprB,KAAA0P,QAAAkI,GAAA5X,KAAA0P,SACA8C,EAAAxS,KAAAkB,QAAAkqB,GACOhS,GAAAgS,EAAAG,KAAAvrB,KAAAkB,MAAAmqB,KAsYPxM,GAAA,YACAK,GAAA,+CACAJ,GAAA,4DACAE,GAAA,uEACAN,IAAe8M,GAAA,QAAAC,GAAA,KAAAC,GAAA,KAAAC,IAAA,YACfpM,GAAA7E,OAAA,GAAAuJ,GAAAC,GACA5E,GAAA,MACAD,GAAA,MAiPAwB,MACAD,GAAAC,GAAA+B,OACAlC,GAAA,EA+CAkL,GAAAlrB,OAAA4jB,QACAuH,IAAArM,EACA/P,IAAAiQ,EACA9V,KAAAmW,EACA7gB,MAAA8gB,EACAnW,MAAA2W,EACA1V,OAAAgW,GACAgL,WAAA9K,GACAsJ,QAXA,WAeA1I,GAAA,EAsoBAvI,GAAA3Y,OAAA4jB,QACAlI,UACA6F,eACA3G,gBACAxC,gBACAlB,+BACAmL,cACA9G,cACAsB,eACAnE,kBACAwG,WACA5G,sBACA2C,eACAF,eACA4E,gBAMAkI,GAAA9Q,GACAsU,IACA1R,QACAuL,YACA/F,gBACAmM,KAAAjL,GACA+C,UAAAjE,GAAAiE,UAEArP,OACA4P,SACAuG,QACAvR,SAIAwS,GAAArM,EACA/P,GAAAiQ,EACA9V,GAAAmW,EACA7gB,GAAA8gB,EACAnW,GAAA2W,EACA1V,GAAAgW,GACAgL,GAAA9K,GAEAiL,GAAAxK,GAEAyK,GAAAnV,KAAsB6U,IACtBK,WAAAxK,GACA8G,YACAwD,SAGAttB,GAAA8pB,YACA9pB,EAAAstB,QACAttB,EAAAotB,OACAptB,EAAAgR,OACAhR,EAAAmL,QACAnL,EAAAS,SACAT,EAAAoL,SACApL,EAAAqM,UACArM,EAAAqtB,cACArtB,EAAA6rB,QAjtBA,SAktBA7rB,EAAAwtB,cACAxtB,EAAA,QAAAytB,GAEAxrB,OAAAC,eAAAlC,EAAA,cAA8CyC,OAAA,SP47B3C","file":"riot/build/riot.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 585:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _riot = __webpack_require__(94);\n\nvar _riot2 = _interopRequireDefault(_riot);\n\n__webpack_require__(586);\n\n__webpack_require__(588);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.onload = function () {\n    _riot2.default.mount(\"*\");\n};\n\n/***/ }),\n\n/***/ 586:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function (t, n) {\n  if (\"object\" == ( false ? \"undefined\" : _typeof(exports)) && \"object\" == ( false ? \"undefined\" : _typeof(module))) module.exports = n(__webpack_require__(94));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(94)], __WEBPACK_AMD_DEFINE_FACTORY__ = (n),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {\n    var e = n(\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) ? require(\"riot\") : t.riot);for (var r in e) {\n      (\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) ? exports : t)[r] = e[r];\n    }\n  }\n}(this, function (t) {\n  return function (t) {\n    function n(r) {\n      if (e[r]) return e[r].exports;var i = e[r] = { i: r, l: !1, exports: {} };return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;\n    }var e = {};return n.m = t, n.c = e, n.d = function (t, e, r) {\n      n.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: r });\n    }, n.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };return n.d(e, \"a\", e), e;\n    }, n.o = function (t, n) {\n      return Object.prototype.hasOwnProperty.call(t, n);\n    }, n.p = \"\", n(n.s = 8);\n  }([function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });var r = e(3);e.d(n, \"array\", function () {\n      return r.a;\n    });var i = e(11);e.d(n, \"tree\", function () {\n      return i.a;\n    });var o = e(12);e.d(n, \"string\", function () {\n      return o.a;\n    });var s = e(13);e.d(n, \"deepMix\", function () {\n      return s.a;\n    });var a = e(14);e.d(n, \"css\", function () {\n      return a.a;\n    });var u = e(15);e.d(n, \"printer\", function () {\n      return u.a;\n    });var c = e(16);e.d(n, \"object\", function () {\n      return c.a;\n    });\n  }, function (n, e) {\n    n.exports = t;\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });var r = e(18);Object.keys(r).forEach(function (t) {\n      \"default\" !== t && \"__esModule\" !== t && Object.defineProperty(n, t, { enumerable: !0, get: function get() {\n          return r[t];\n        } });\n    });var i = e(19);Object.keys(i).forEach(function (t) {\n      \"default\" !== t && \"__esModule\" !== t && Object.defineProperty(n, t, { enumerable: !0, get: function get() {\n          return i[t];\n        } });\n    });var o = e(20);Object.keys(o).forEach(function (t) {\n      \"default\" !== t && \"__esModule\" !== t && Object.defineProperty(n, t, { enumerable: !0, get: function get() {\n          return o[t];\n        } });\n    });\n  }, function (t, n, e) {\n    \"use strict\";\n    e.d(n, \"a\", function () {\n      return r;\n    });var r = function r(t) {\n      return { last: function last() {\n          return t.length > 0 ? t[t.length - 1] : null;\n        }, in: function _in(n, e) {\n          return t.filter(function (t) {\n            return n.indexOf(t) >= 0 && (!e || e(t));\n          });\n        }, notIn: function notIn(n, e) {\n          return t.filter(function (t) {\n            return n.indexOf(t) < 0 && (!e || e(t));\n          });\n        }, is: function is(n, e) {\n          var r = n.isIn,\n              i = void 0 === r ? [] : r,\n              o = n.notIn,\n              s = void 0 === o ? [] : o;return t.filter(function (t) {\n            return i.reduce(function (n, e) {\n              return e.indexOf(t) >= 0 && n;\n            }, !0) && s.reduce(function (n, e) {\n              return e.indexOf(t) < 0 && n;\n            }, !0) && (!e || e(t));\n          });\n        }, contains: function contains(n) {\n          return t.indexOf(n) >= 0;\n        }, allIn: function allIn(n) {\n          return t.every(function (t) {\n            return n.indexOf(t) >= 0;\n          });\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });var r = e(17);e.d(n, \"TreeNode\", function () {\n      return r.b;\n    }), e.d(n, \"RootNode\", function () {\n      return r.a;\n    });var i = e(6);e.d(n, \"selectionStrategies\", function () {\n      return i.c;\n    }), e.d(n, \"clickStrategies\", function () {\n      return i.a;\n    }), e.d(n, \"foldStrategies\", function () {\n      return i.b;\n    });var o = e(7);e.d(n, \"defaults\", function () {\n      return o.a;\n    });var s = e(5);e.d(n, \"dragndrop\", function () {\n      return s.a;\n    }), e.d(n, \"utils\", function () {\n      return s.c;\n    }), e.d(n, \"nodeEvents\", function () {\n      return s.b;\n    }), e.d(n, \"wrapEvents\", function () {\n      return s.d;\n    });\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t) {\n      if (Array.isArray(t)) {\n        for (var n = 0, e = Array(t.length); n < t.length; n++) {\n          e[n] = t[n];\n        }return e;\n      }return Array.from(t);\n    }e.d(n, \"a\", function () {\n      return s;\n    }), e.d(n, \"c\", function () {\n      return u;\n    }), e.d(n, \"b\", function () {\n      return f;\n    }), e.d(n, \"d\", function () {\n      return d;\n    });var i = e(0),\n        o = Object.assign || function (t) {\n      for (var n = 1; n < arguments.length; n++) {\n        var e = arguments[n];for (var r in e) {\n          Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n        }\n      }return t;\n    },\n        s = { selection: function selection(t, n) {\n        return { draggable: !0, droppable: !0, drag: function drag(t, n, e) {\n            n.dataTransfer && n.dataTransfer.setData(\"application/json\", JSON.stringify(e.selection));\n          }, guard: function guard(t, n, e) {\n            if (n && n.dataTransfer && n.dataTransfer.types.indexOf(\"application/json\") < 0) return !1;return function () {\n              return t && Object(i.array)(e.selection).contains(t);\n            }() || function () {\n              return e.ancestors && e.ancestors.reduce(function (t, n) {\n                return t || Object(i.array)(e.selection).contains(n);\n              }, !1);\n            }();\n          }, drop: function drop(e, o, s) {\n            var a = Object(i.tree)(t(), s.category).filter(function (t) {\n              return s.selection.indexOf(t) < 0;\n            }),\n                u = e ? e[s.category] && e[s.category] instanceof Array ? e : Object(i.array)(s.ancestors).last() : null;u ? u[s.category] = [].concat(r(u[s.category]), r(s.selection)) : a = [].concat(r(a), r(s.selection)), n(a);\n          } };\n      }, pluck: function pluck(t, n) {\n        return { draggable: !0, backup: [], drag: function drag(e, r, o) {\n            a = JSON.stringify(t()), r.dataTransfer && r.dataTransfer.setData(\"application/json\", JSON.stringify(e)), setTimeout(function () {\n              return n(Object(i.tree)(t(), o.category).filter(function (t) {\n                return t !== e;\n              }));\n            }, 20);\n          }, cancel: function cancel() {\n            n(JSON.parse(a));\n          } };\n      }, paste: function paste(t, n) {\n        return { droppable: !0, drop: function drop(e, o, s) {\n            if (o.dataTransfer && o.dataTransfer.types.indexOf(\"application/json\") > -1) {\n              var a = JSON.parse(o.dataTransfer.getData(\"application/json\")),\n                  u = [].concat(r(t())),\n                  c = e ? e[s.category] && e[s.category] instanceof Array ? e : Object(i.array)(s.ancestors).last() : null;c ? c[s.category] = [].concat(r(c[s.category]), [a]) : u = [].concat(r(u), [a]), n(u);\n            }\n          } };\n      } },\n        a = \"[]\",\n        u = { filesystem: function filesystem(t) {\n        var n = t.dataTransfer ? t.dataTransfer.items : null;if (n && n.length > 0 && \"file\" === n[0].kind) {\n          for (var e = [], r = 0; r < n.length; r++) {\n            var i = n[r].webkitGetAsEntry() || n[r].getAsFile();i && e.push(i);\n          }return e;\n        }return null;\n      } },\n        c = !1,\n        f = { onDragStart: function onDragStart(t) {\n        return function (n) {\n          n.stopPropagation(), this.inputs.get().dragndrop.onDrag(t, n, this.inputs.get());\n        };\n      }, onDragOver: function onDragOver(t) {\n        return function (n) {\n          n.preventDefault(), n.stopPropagation(), c || (c = !0, this.inputs.get().dragndrop.guard && this.inputs.get().dragndrop.guard(t, n, this.inputs.get()) ? (n.dataTransfer && (n.dataTransfer.dropEffect = \"none\"), i.css.addClass(n.currentTarget, this.mixCss(\"nodrop\"))) : i.css.addClass(n.currentTarget, this.mixCss(\"dragover\")), requestAnimationFrame(function () {\n            c = !1;\n          }));\n        };\n      }, onDragEnter: function onDragEnter(t) {\n        return function (n) {\n          if (n.preventDefault(), n.stopPropagation(), t && (this.hasChildren(t) || this.isAsync(t)) && i.css.hasClass(n.target, this.mixCss(\"opener\"))) {\n            var e = this.state.get().unfolded.filter(function (n) {\n              return n !== t;\n            });e.push(t), this.state.set({ unfolded: e });\n          }\n        };\n      }, onDragLeave: function onDragLeave(t) {\n        t.stopPropagation(), i.css.removeClass(t.currentTarget, this.mixCss(\"dragover\")), i.css.removeClass(t.currentTarget, this.mixCss(\"nodrop\"));\n      }, onDrop: function onDrop(t) {\n        return function (n) {\n          n.stopPropagation(), i.css.removeClass(n.currentTarget, this.mixCss(\"dragover\")), i.css.removeClass(n.currentTarget, this.mixCss(\"nodrop\")), this.inputs.get().dragndrop.onDrop(t, n, this.inputs.get());\n        };\n      }, onDragEnd: function onDragEnd(t) {\n        return function (n) {\n          n.stopPropagation(), n.dataTransfer && \"none\" === n.dataTransfer.dropEffect && this.inputs.get().dragndrop.onCancel(t, n, this.inputs.get());\n        };\n      } },\n        d = function d() {\n      var t = this;return o({}, this.inputs.get().dragndrop, { onDrag: function onDrag(n, e, r) {\n          Object(i.array)(t.inputs.get().selection).contains(n) || t.onSelect(n, r.ancestors, r.neighbours), t.outputs.onDrag && t.outputs.onDrag(n, e, r);\n        }, onDrop: function onDrop(n, e, r) {\n          e.preventDefault(), t.outputs.onDrop && t.outputs.onDrop(n, e, r);\n        }, onCancel: function onCancel(n, e, r) {\n          e.preventDefault(), e.dataTransfer && \"none\" === e.dataTransfer.dropEffect && t.outputs.onCancel && t.outputs.onCancel(n, e, r);\n        } });\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t) {\n      if (Array.isArray(t)) {\n        for (var n = 0, e = Array(t.length); n < t.length; n++) {\n          e[n] = t[n];\n        }return e;\n      }return Array.from(t);\n    }e.d(n, \"c\", function () {\n      return u;\n    }), e.d(n, \"a\", function () {\n      return c;\n    }), e.d(n, \"b\", function () {\n      return f;\n    });var i = e(0),\n        o = function () {\n      function t(t, n) {\n        var e = [],\n            r = !0,\n            i = !1,\n            o = void 0;try {\n          for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (e.push(s.value), !n || e.length !== n); r = !0) {}\n        } catch (t) {\n          i = !0, o = t;\n        } finally {\n          try {\n            !r && a.return && a.return();\n          } finally {\n            if (i) throw o;\n          }\n        }return e;\n      }return function (n, e) {\n        if (Array.isArray(n)) return n;if (Symbol.iterator in Object(n)) return t(n, e);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        s = function s(t, n, e, r) {\n      return Object(i.array)(n).contains(t) ? [] : [t];\n    },\n        a = function a(t, n, e, r) {\n      var o = !1,\n          s = n.filter(function (n) {\n        return o || (o = n === t), n !== t && r.indexOf(n) < 0;\n      });return !o && t[this.inputs.get().category] && t[this.inputs.get().category] instanceof Array && Object(i.tree)(t[this.inputs.get().category], this.inputs.get().category).visit(function (t) {\n        s = Object(i.array)(s).notIn(t);\n      }), o || s.push(t), s;\n    },\n        u = { single: s, multiple: a, modifiers: function modifiers(t, n, e, u) {\n        var c = this;if (this.modifiers.control || this.modifiers.meta) return this.lastSelection = t, delete this.lastIndex, delete this.lastPivot, a.bind(this)(t, n, e, u);if (this.modifiers.shift) {\n          if (!this.lastSelection) return n;var f = e.indexOf(this.lastSelection);if (f < 0) return n;var d = n.slice(),\n              l = e.indexOf(t);if (f >= 0) {\n            var p;if (this.lastPivot) {\n              var g = e.indexOf(this.lastPivot),\n                  h = f > g ? [g, f] : [f, g],\n                  v = o(h, 2),\n                  y = v[0],\n                  b = v[1],\n                  m = e.slice(y, b + 1);d = Object(i.array)(d).notIn(m);\n            }this.lastPivot = t;var O = f > l ? [l, f] : [f, l],\n                x = o(O, 2),\n                D = x[0],\n                j = x[1],\n                w = this.inputs.get().disabled ? e.slice(D, j + 1).filter(function (t) {\n              return !c.inputs.get().disabled(t);\n            }) : e.slice(D, j + 1);d = Object(i.array)(d).notIn(w), (p = d).push.apply(p, r(w));\n          }return d;\n        }return this.lastSelection = t, delete this.lastIndex, delete this.lastPivot, s.bind(this)(t, n.length > 1 ? [] : n, e, u);\n      }, ancestors: function (t) {\n        function n(n, e, r, i) {\n          return t.apply(this, arguments);\n        }return n.toString = function () {\n          return t.toString();\n        }, n;\n      }(function (t, n, e, o) {\n        return 0 === n.length ? [t] : Object(i.array)(n).contains(t) ? [].concat(r(o)) : [].concat(r(o), [t]);\n      }) },\n        c = { \"unfold-on-selection\": function unfoldOnSelection(t) {\n        if (!this.isSelected(t)) {\n          var n = this.state.get().unfolded.filter(function (n) {\n            return n !== t;\n          });n.push(t), this.state.set({ unfolded: n });\n        }\n      }, \"toggle-fold\": function toggleFold(t) {\n        var n = this.state.get().unfolded.filter(function (n) {\n          return n !== t;\n        });n.length === this.state.get().unfolded.length && n.push(t), this.state.set({ unfolded: n });\n      } },\n        f = { \"opener-control\": function openerControl(t) {\n        return !Object(i.array)(this.state.get().unfolded).contains(t);\n      }, \"not-selected\": function notSelected(t) {\n        return !this.isSelected(t);\n      }, \"no-child-selection\": function noChildSelection(t) {\n        var n = this;return !function t(e) {\n          return n.isSelected(e) || e[n.inputs.get().category] && e[n.inputs.get().category] instanceof Array && e[n.inputs.get().category].some(t);\n        }(t);\n      }, \"max-depth\": function maxDepth() {\n        return !(!this.inputs.get().maxDepth || isNaN(parseInt(this.inputs.get().maxDepth, 10))) && this.inputs.get().depth >= parseInt(this.inputs.get().maxDepth, 10);\n      } };\n  }, function (t, n, e) {\n    \"use strict\";\n    e.d(n, \"a\", function () {\n      return r;\n    });var r = { labels: { \"search.placeholder\": \"Search ...\" }, css: { TreeView: \"TreeView\", opener: \"opener\", depth: \"depth\", selected: \"selected\", category: \"category\", folded: \"folded\", disabled: \"disabled\", async: \"async\", loading: \"loading\", nodrop: \"nodrop\", dragover: \"dragover\", search: \"search\", item: \"item\" }, strategies: { selection: [\"single\"], click: [], fold: [\"not-selected\", \"no-child-selection\"] }, display: function display(t) {\n        return t.toString();\n      }, async: function async(t) {\n        return t();\n      }, noOpener: !1, dragndrop: { draggable: !1, droppable: !1 } };\n  }, function (t, n, e) {\n    \"use strict\";\n    e(9);\n  }, function (t, n, e) {\n    \"use strict\";\n    e(10), e(21), e(22);\n  }, function (t, n, e) {\n    e(1).tag2(\"treeview\", '<div class=\"{rootNode.mixCss(⁗TreeView⁗)}\"> <input type=\"search\" class=\"{rootNode.mixCss(⁗search⁗)}\" if=\"{inputs.get().search}\" placeholder=\"{inputs.get().labels[⁗search.placeholder⁗]}\" onkeyup=\"{onSearch}\"> <treeviewnode opts=\"{inputs.get()}\" model=\"{inputs.get().sort ? inputs.get().model.sort(inputs.get().sort) : inputs.get().model}\" filteredmodel=\"{filtered}\" onselect=\"{rootNode.onSelect}\" dragndrop=\"{rootNode.wrapDragNDrop()}\" ancestors=\"{[]}\" searched=\"{search.trim()}\" depth=\"{+⁗0⁗}\"> </TreeViewNode> </div>', \"\", \"\", function (t) {\n      \"use strict\";\n      var n = Object.assign || function (t) {\n        for (var n = 1; n < arguments.length; n++) {\n          var e = arguments[n];for (var r in e) {\n            Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n          }\n        }return t;\n      },\n          r = this,\n          i = e(0),\n          o = e(4),\n          s = e(2);this.mixin((0, s.optsMixin)()), this.mixin((0, s.listenerMixin)({ eventType: \"keyup\", callback: function callback(t) {\n          return r.rootNode.onKey(t);\n        }, autoMount: !0 })), this.mixin((0, s.listenerMixin)({ eventType: \"keydown\", callback: function callback(t) {\n          return r.rootNode.onKey(t);\n        }, autoMount: !0 })), this.filtered = null, this.search = \"\", this.onSearch = function (t) {\n        var n = t.currentTarget.value;r.search = n, r.filtered = n.trim() ? (0, i.tree)(r.inputs.get().model, r.inputs.get().category).treeFilter(r.inputs.get().search(n.trim())) : null;\n      }, this.inputs = { get: function get() {\n          return n({}, o.defaults, r.opts, { onSelect: r.opts.onselect });\n        } }, this.outputs = { onSelect: this.inputs.get().onselect, onDrag: this.inputs.get().dragndrop && this.inputs.get().dragndrop.drag, onDrop: this.inputs.get().dragndrop && this.inputs.get().dragndrop.drop, onCancel: this.inputs.get().dragndrop && this.inputs.get().dragndrop.cancel }, this.state = { get: function get() {\n          return n({}, r);\n        }, set: function set(t) {\n          for (var n in t) {\n            n in r && (r[n] = t[n]);\n          }\n        } }, this.rootNode = new o.RootNode(this.inputs, this.outputs, this.state, this.update);\n    });\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t) {\n      if (Array.isArray(t)) {\n        for (var n = 0, e = Array(t.length); n < t.length; n++) {\n          e[n] = t[n];\n        }return e;\n      }return Array.from(t);\n    }e.d(n, \"a\", function () {\n      return o;\n    });var i = e(3),\n        o = function o(t, n) {\n      return { flatten: function flatten() {\n          for (var e = [], o = [t]; o.length > 0;) {\n            var s = o.pop();s instanceof Array && (e = [].concat(r(Object(i.a)(e).notIn(s)), r(s)), o = [].concat(r(o), r(s.filter(function (t) {\n              return t[n];\n            }).map(function (t) {\n              return t[n];\n            }))));\n          }return e;\n        }, filter: function filter(e) {\n          var r = t.filter(e);return function t(r) {\n            r.forEach(function (r) {\n              r[n] && r[n] instanceof Array && (r[n] = r[n].filter(e), t(r[n]));\n            });\n          }(r), r;\n        }, treeFilter: function treeFilter(e) {\n          var r = new Map();return function t(r, i) {\n            r.forEach(function (r) {\n              if (r[n] && r[n] instanceof Array) {\n                var o = new Map();t(r[n], o), o.size > 0 ? i.set(r, o) : e(r) && i.set(r, new Map());\n              } else e(r) && i.set(r, null);\n            });\n          }(t, r), r;\n        }, add: function add(e, i) {\n          for (var o = [t]; o.length > 0;) {\n            var s = o.pop(),\n                a = s.indexOf(e);if (a >= 0 && s[a][n]) return s[a][n] = s[a][n].slice(), s[a][n].push(i), t;o = [].concat(r(o), r(s.filter(function (t) {\n              return t[n];\n            }).map(function (t) {\n              return t[n];\n            })));\n          }return t;\n        }, visit: function visit(e) {\n          for (var r = [t]; r.length > 0;) {\n            var i = r.pop();e(i), i.forEach(function (t) {\n              return t[n] && t[n] instanceof Array ? r.push(t[n]) : null;\n            });\n          }\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    e.d(n, \"a\", function () {\n      return r;\n    });var r = function r(t) {\n      return { contains: function contains(n) {\n          return !!t && !!t.match(new RegExp(\".*\" + n + \".*\", \"gi\"));\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t) {\n      if (Array.isArray(t)) {\n        for (var n = 0, e = Array(t.length); n < t.length; n++) {\n          e[n] = t[n];\n        }return e;\n      }return Array.from(t);\n    }e.d(n, \"a\", function () {\n      return s;\n    });var i = Object.assign || function (t) {\n      for (var n = 1; n < arguments.length; n++) {\n        var e = arguments[n];for (var r in e) {\n          Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n        }\n      }return t;\n    },\n        o = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n      return typeof t === \"undefined\" ? \"undefined\" : _typeof(t);\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t === \"undefined\" ? \"undefined\" : _typeof(t);\n    },\n        s = function t(n, e) {\n      var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];if (!n || !e || \"object\" !== (void 0 === n ? \"undefined\" : o(n)) || \"object\" !== (void 0 === e ? \"undefined\" : o(e))) return n;var a = i({}, n, e);for (var u in e) {\n        e.hasOwnProperty(u) && (e[u] instanceof Array && n[u] instanceof Array ? a[u] = s ? [].concat(r(n[u]), r(e[u])) : a[u] = e[u] : \"object\" === o(e[u]) && \"object\" === o(n[u]) && (a[u] = t(n[u], e[u], s)));\n      }return a;\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    e.d(n, \"a\", function () {\n      return r;\n    });var r = { classes: function classes(t) {\n        var n = [];for (var e in t) {\n          t[e] && n.push(e);\n        }return n.join(\" \");\n      }, addClass: function addClass(t, n) {\n        t instanceof HTMLElement && (t.className = t.className.split(\" \").filter(function (t) {\n          return t !== n;\n        }).join(\" \") + \" \" + n);\n      }, removeClass: function removeClass(t, n) {\n        t instanceof HTMLElement && (t.className = t.className.split(\" \").filter(function (t) {\n          return t !== n;\n        }).join(\" \"));\n      }, hasClass: function hasClass(t, n) {\n        return t instanceof HTMLElement && t.className.indexOf(n) >= 0;\n      } };\n  }, function (t, n, e) {\n    \"use strict\";\n    e.d(n, \"a\", function () {\n      return r;\n    });var r = { debug: function debug(t, n) {\n        var e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log;e(\"%cDEBUG%c \" + t, \"background-color: red; color: white; font-size: 1.1em; font-weight: bold; padding: 3px 10px; border-radius: 5px\", \"color: #444; font-weight: bold; font-size: 1.1em\"), e(\"%c\" + n, \"color: #222; font-weight: bold\");\n      } };\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t, n, e) {\n      return n in t ? Object.defineProperty(t, n, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = e, t;\n    }e.d(n, \"a\", function () {\n      return o;\n    });var i = function () {\n      function t(t, n) {\n        var e = [],\n            r = !0,\n            i = !1,\n            o = void 0;try {\n          for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (e.push(s.value), !n || e.length !== n); r = !0) {}\n        } catch (t) {\n          i = !0, o = t;\n        } finally {\n          try {\n            !r && a.return && a.return();\n          } finally {\n            if (i) throw o;\n          }\n        }return e;\n      }return function (n, e) {\n        if (Array.isArray(n)) return n;if (Symbol.iterator in Object(n)) return t(n, e);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        o = function o(t) {\n      if (!(t && t instanceof Object)) throw new Error(\"Bad object format\");return { shallowCompare: function shallowCompare(n, e) {\n          var r = !0;for (var i in t) {\n            if (t.hasOwnProperty(i) && !(e && e.indexOf(i) >= 0) && n[i] !== t[i]) return void (r = !1);\n          }return r;\n        }, filter: function filter(n) {\n          var e = {};for (var r in t) {\n            t.hasOwnProperty(r) && n(t[r]) && (e[r] = t[r]);\n          }return e;\n        }, map: function map(n) {\n          var e = {};for (var r in t) {\n            t.hasOwnProperty(r) && (e[r] = n(t[r]));\n          }return e;\n        }, fullMap: function fullMap(n) {\n          var e = {};for (var r in t) {\n            if (t.hasOwnProperty(r)) {\n              var o = n(r, t[r]),\n                  s = i(o, 2),\n                  a = s[0],\n                  u = s[1];e[a] = u;\n            }\n          }return e;\n        }, nestPrefix: function nestPrefix(n) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function (t) {\n            return t;\n          },\n              i = r({}, n, {});for (var o in t) {\n            t.hasOwnProperty(o) && o.startsWith(n) ? i[n][e(o.substring(n.length))] = t[o] : i[o] = t[o];\n          }return i;\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    function r(t, n, e) {\n      return n in t ? Object.defineProperty(t, n, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = e, t;\n    }function i(t, n) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return !n || \"object\" != (typeof n === \"undefined\" ? \"undefined\" : _typeof(n)) && \"function\" != typeof n ? t : n;\n    }function o(t, n) {\n      if (\"function\" != typeof n && null !== n) throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof n === \"undefined\" ? \"undefined\" : _typeof(n)));t.prototype = Object.create(n && n.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n);\n    }function s(t, n) {\n      if (!(t instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n    }e.d(n, \"b\", function () {\n      return p;\n    }), e.d(n, \"a\", function () {\n      return g;\n    });var a = e(0),\n        u = e(5),\n        c = e(6),\n        f = e(7),\n        d = function () {\n      function t(t, n) {\n        for (var e = 0; e < n.length; e++) {\n          var r = n[e];r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }return function (n, e, r) {\n        return e && t(n.prototype, e), r && t(n, r), n;\n      };\n    }(),\n        l = function t(n, e, r, i) {\n      s(this, t), this.inputs = n, this.outputs = e, this.state = r, this.refresh = i;\n    },\n        p = function (t) {\n      function n() {\n        var t, e, o, d;s(this, n);for (var l = arguments.length, p = Array(l), g = 0; g < l; g++) {\n          p[g] = arguments[g];\n        }return e = o = i(this, (t = n.__proto__ || Object.getPrototypeOf(n)).call.apply(t, [this].concat(p))), o.isSelected = function (t) {\n          return Object(a.array)(o.inputs.get().selection).contains(t);\n        }, o.isFolded = function (t) {\n          var n = o.inputs.get().strategies;return (!o.inputs.get().searched || o.isAsync(t)) && (n && n.fold || []).map(function (t) {\n            return (c.b[t] || t).bind(o);\n          }).reduce(function (n, e) {\n            return n && e(t, n);\n          }, !0);\n        }, o.hasChildren = function (t) {\n          return t[o.inputs.get().category] && t[o.inputs.get().category] instanceof Array;\n        }, o.isAsync = function (t) {\n          return !!t && [o.inputs.get().category] && \"function\" == typeof t[o.inputs.get().category];\n        }, o.isDisabled = function (t) {\n          var n = o.inputs.get().disabled;return !!n && n(t);\n        }, o.isDraggable = function (t) {\n          return t && o.inputs.get().dragndrop.draggable && (\"function\" != typeof o.inputs.get().dragndrop.draggable || o.inputs.get().dragndrop.draggable(t));\n        }, o.isDroppable = function (t) {\n          return o.inputs.get().dragndrop.droppable && (\"function\" != typeof o.inputs.get().dragndrop.droppable || o.inputs.get().dragndrop.droppable(t));\n        }, o.mixCss = function (t) {\n          return o.inputs.get().css[t] || f.a.css[t];\n        }, o.ulCss = function () {\n          return a.css.classes(r({}, o.mixCss(\"depth\") + \"-\" + (o.inputs.get().depth || 0), !0));\n        }, o.liCss = function (t) {\n          var n;return a.css.classes((n = {}, r(n, o.mixCss(\"selected\"), o.isSelected(t)), r(n, o.mixCss(\"category\"), o.hasChildren(t) || o.isAsync(t)), r(n, o.mixCss(\"folded\"), o.hasChildren(t) || o.isAsync(t) ? o.isFolded(t) : null), r(n, o.mixCss(\"disabled\"), o.isDisabled(t)), r(n, o.mixCss(\"async\"), o.isAsync(t) && o.isFolded(t)), r(n, o.mixCss(\"loading\"), o.isAsync(t) && !o.isFolded(t)), n));\n        }, o.pending = [], o.unwrapPromise = function (t) {\n          o.pending.push(t);var n = o.inputs.get().async;return n ? n(t[o.inputs.get().category]).then(function (n) {\n            t[o.inputs.get().category] = n, o.refresh();\n          }).catch(function (t) {\n            throw t;\n          }).then(function () {\n            return o.pending = o.pending.filter(function (n) {\n              return n !== t;\n            });\n          }) : Promise.reject(new Error(\"Missing async function.\"));\n        }, o.onClick = function (t) {\n          return function (n) {\n            if (!o.isDisabled(t)) {\n              var e = o.inputs.get().strategies;(e && e.click || []).map(function (t) {\n                return (c.a[t] || t).bind(o);\n              }).forEach(function (e) {\n                return e(t, n, o.inputs.get().ancestors, o.inputs.get().model);\n              }), o.inputs.get().onSelect(t, o.inputs.get().ancestors, o.inputs.get().model), n.stopPropagation();\n            }\n          };\n        }, o.getDragEvents = function (t) {\n          if (arguments.length > 1 && void 0 !== arguments[1] && !arguments[1]) return {};var n = { draggable: o.isDraggable(t), onDragStart: o.isDraggable(t) && u.b.onDragStart(t).bind(o), onDragOver: o.isDroppable(t) && u.b.onDragOver(t).bind(o), onDragEnter: o.isDroppable(t) && u.b.onDragEnter(t).bind(o), onDragLeave: o.isDroppable(t) && u.b.onDragLeave.bind(o), onDrop: o.isDroppable(t) && u.b.onDrop(t).bind(o), onDragEnd: o.isDraggable(t) && u.b.onDragEnd(t).bind(o) };for (var e in n) {\n            n[e] || delete n[e];\n          }return n;\n        }, d = e, i(o, d);\n      }return o(n, t), d(n, [{ key: \"onOpener\", value: function value(t) {\n          var n = this;return function (e) {\n            var r = n.state.get().unfolded.filter(function (n) {\n              return n !== t;\n            });r.length === n.state.get().unfolded.length && r.push(t), n.state.set({ unfolded: r }), e.stopPropagation();\n          };\n        } }]), n;\n    }(l),\n        g = function (t) {\n      function n() {\n        var t, e, r, o;s(this, n);for (var d = arguments.length, l = Array(d), p = 0; p < d; p++) {\n          l[p] = arguments[p];\n        }return e = r = i(this, (t = n.__proto__ || Object.getPrototypeOf(n)).call.apply(t, [this].concat(l))), r.modifiers = {}, r.onKey = function (t) {\n          r.modifiers = { control: t.getModifierState(\"Control\"), meta: t.getModifierState(\"Meta\"), shift: t.getModifierState(\"Shift\") };\n        }, r.onSelect = function (t, n, e) {\n          var i = r.inputs.get().strategies.selection || [],\n              o = i.map(function (t) {\n            return (c.c[t] || t).bind(r);\n          }).reduce(function (r, i) {\n            return i(t, r, e, n);\n          }, r.inputs.get().selection);return r.outputs.onSelect(o, t, n, e), o;\n        }, r.wrapDragNDrop = u.d.bind(r), r.mixCss = function (t) {\n          return r.inputs.get().css[t] || f.a.css[t];\n        }, r.filterTree = function (t) {\n          var n = r.inputs.get().search;return n && t.trim() ? Object(a.tree)(r.inputs.get().model, r.inputs.get().category).treeFilter(n(t.trim())) : null;\n        }, o = e, i(r, o);\n      }return o(n, t), n;\n    }(l);\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });n.optsMixin = function () {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"opts\";return { init: function init() {\n          this.on(\"update\", this.updateOpts), this._originalOpts = Object.keys(this.opts), this.updateOpts();\n        }, updateOpts: function updateOpts() {\n          if (this.opts) for (var n in this.opts[t]) {\n            ~this._originalOpts.indexOf(n) || (this.opts[n] = this.opts[t][n]);\n          }\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });n.transitionMixin = function (t) {\n      return { init: function init() {\n          var n = this;if (\"transition\" in this.opts) {\n            var e = this.opts.transition.name,\n                r = this.unmount,\n                i = function i() {\n              var r = (t || function () {\n                return n.root;\n              })();r && (r.classList.add(e), r.classList.add(e + \"-mount\"), setTimeout(function () {\n                r.classList.remove(e + \"-mount\");\n              }, 10));\n            },\n                o = !1,\n                s = function s() {\n              if (!o) {\n                o = !0;var i = (t || function () {\n                  return n.root;\n                })();if (!i) return r.call(n);i.addEventListener(\"transitionend\", function () {\n                  r.call(n);\n                }), i.classList.add(e + \"-unmount\");\n              }\n            };this.one(\"mount\", i), Object.defineProperty(this, \"unmount\", { value: s });\n          }\n        } };\n    };\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });n.listenerMixin = function (t) {\n      var n = t.eventType,\n          e = void 0 === n ? \"click\" : n,\n          r = t.callback,\n          i = t.regulate,\n          o = void 0 !== i && i;return { init: function init() {\n          var t = !1,\n              n = function n(_n) {\n            r && (o ? (t || window.requestAnimationFrame(function () {\n              return r(_n, function () {\n                return t = !1;\n              });\n            }), t = !0) : r(_n));\n          };this.one(\"mount\", function () {\n            document.addEventListener(e, n);\n          }), this.one(\"unmount\", function () {\n            document.removeEventListener(e, n);\n          });\n        } };\n    };\n  }, function (t, n, e) {\n    e(1).tag2(\"treeviewnode\", '<ul if=\"{!opts.folded && !opts.loading}\" data-is=\"with-transition\" transition=\"{opts.transition}\" class=\"{node.ulCss()}\" ondragover=\"{!opts.depth ? rootEvents.onDragOver : null}\" ondragenter=\"{!opts.depth ? rootEvents.onDragEnter : null}\" ondragleave=\"{!opts.depth ? rootEvents.onDragLeave : null}\" ondrop=\"{!opts.depth ? rootEvents.onDrop : null}\"> <li each=\"{item in getModel()}\" class=\"{node.liCss(item)}\" draggable=\"{node.getDragEvents(item).draggable}\" ondragstart=\"{node.getDragEvents(item).onDragStart}\" ondragover=\"{node.getDragEvents(item).onDragOver}\" ondragenter=\"{node.getDragEvents(item).onDragEnter}\" ondragleave=\"{node.getDragEvents(item).onDragLeave}\" ondragend=\"{node.getDragEvents(item).onDragEnd}\" ondrop=\"{node.getDragEvents(item).onDrop}\"> <span class=\"{parent.node.mixCss(⁗item⁗)}\" onclick=\"{parent.node.onClick(item)}\"> <virtual if=\"{!parent.opts.displaytag}\"> {parent.opts.display(item, parent.opts)} </virtual> <virtual if=\"{parent.opts.displaytag}\" data-is=\"{parent.opts.displaytag(item, parent.opts)}\" item=\"{item}\"></virtual> <span if=\"{node.hasChildren(item) || node.isAsync(item) && !parent.opts.noopener}\" class=\"{node.mixCss(⁗opener⁗)}\" onclick=\"{node.onOpener(item)}\"></span> </span> <treeviewnode if=\"{node.hasChildren(item) || node.isAsync(item)}\" opts=\"{parent.opts}\" model=\"{getChildModel(item)}\" filteredmodel=\"{getChildFiltered(item)}\" ancestors=\"{getAncestors(item)}\" depth=\"{parent.opts.depth + 1}\" folded=\"{node.isFolded(item)}\" loading=\"{node.isAsync(item) && !node.isFolded(item)}\"> </TreeViewNode> </li> </ul> <span if=\"{opts.loading}\"></span>', \"\", \"\", function (t) {\n      \"use strict\";\n      var n = this,\n          r = e(4),\n          i = e(2);this.mixin((0, i.optsMixin)()), this.unfolded = [], this.getModel = function () {\n        return n.opts.searched ? n.opts.model.filter(function (t) {\n          return n.opts.filteredmodel.has(t);\n        }) : n.opts.model;\n      }, this.getChildModel = function (t) {\n        var e = t[n.opts.category];return n.node.isAsync(t) && !n.node.isFolded(t) && n.node.pending.indexOf(t) < 0 && n.node.unwrapPromise(t), n.node.isAsync(t) || (e = n.opts.sort ? e.sort(n.opts.sort) : e), e;\n      }, this.getChildFiltered = function (t) {\n        return n.opts.searched ? n.opts.filteredmodel.get(t) : null;\n      }, this.getAncestors = function (t) {\n        return [].concat(n.opts.ancestors, [t]);\n      };var o = function o() {\n        n.opts.onSelect = n.opts.onselect;\n      };this.on(\"update\", o), o(), this.inputs = { get: function get() {\n          return n.opts;\n        } }, this.state = { get: function get() {\n          return n;\n        }, set: function set(t) {\n          for (var e in t) {\n            e in n && (n[e] = t[e]);\n          }\n        } }, this.node = new r.TreeNode(this.inputs, null, this.state, this.update), this.rootEvents = this.node.getDragEvents();\n    });\n  }, function (t, n, e) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: !0 });var r = e(1),\n        i = function (t) {\n      return t && t.__esModule ? t : { default: t };\n    }(r),\n        o = e(2);n.default = i.default.tag(\"with-transition\", !1, function (t) {\n      var n = this;this.mixin((0, o.transitionMixin)());var e = function e() {\n        for (var t in n.parent) {\n          n.parent.hasOwnProperty(t) && (n[t] = n.parent[t]);\n        }\n      };e(), this.on(\"update\", e);\n    });\n  }]);\n});\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(587)(module)))\n\n/***/ }),\n\n/***/ 587:\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n\n/***/ 588:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(589);\n\n__webpack_require__(590);\n\n/***/ }),\n\n/***/ 589:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var riot = __webpack_require__(94)\n    riot.tag2('app', '<div class=\"App\"> <div class=\"chapter\"> <p> This page covers the <em class=\"highlight\"><a href=\"http://riotjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Riot.js</a></em> implementation of the <em><a href=\"../#Introduction\">Bosket library</a></em>.<br> Versatile and flexible, Bosket eases the creation and design of tree view components.<br><br> As a matter of fact <em><a href=\"https://github.com/elbywan/bosket/tree/master/docs/riot/plan\" target=\"_blank\" rel=\"noopener noreferrer\">this whole documentation</a></em> is built around Bosket using <em><a href=\"https://github.com/elbywan/bosket/blob/master/docs/riot/components/Planner.tag\" target=\"_blank\" rel=\"noopener noreferrer\">a custom component</a></em> which automatically creates the table of contents and the anchors.<br> <br> Multiple use case examples (including the source code and the css stylesheet) are provided alongside the documentation. </p> <treeviewdemo></treeviewdemo> </div> </div>', '', '', function(opts) {\n\"use strict\";\n\n__webpack_require__(154);\n});\n\n    \n  \n\n/***/ }),\n\n/***/ 590:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var riot = __webpack_require__(94)\n    riot.tag2('treeviewdemo', '<treeview opts=\"{options}\"></treeview> <p> <span if=\"{options.selection.length === 0}\">No elements are</span> <span if=\"{options.selection.length === 1}\">One element is</span> <span if=\"{options.selection.length > 1}\">{options.selection.length} elements are</span> selected. </p> <div class=\"select-blocks\"> <button each=\"{item in options.selection}\" onclick=\"{updateSelection(item)}\"> {item.label} </button> </div>', '', '', function(opts) {\n\"use strict\";\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _this = this;\n\n// Model\n\nvar _tools = __webpack_require__(11);\n\nvar _dragndrop = __webpack_require__(34);\n\nvar _riot = __webpack_require__(94);\n\nvar _riot2 = _interopRequireDefault(_riot);\n\nvar _TreeViewModel = __webpack_require__(156);\n\nvar _TreeViewModel2 = _interopRequireDefault(_TreeViewModel);\n\n__webpack_require__(591);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nthis.dragImage = new Image();\nthis.dragImage.src = \"../assets/drag-image.png\";\n\n_riot2.default.tag(\"wrapped-label\", \"<a>{ opts.item.label }</a>\");\n\nthis.options = {\n    files: [\"./components/Demos/TreeView/TreeViewDemo.js\", \"./components/Demos/TreeView/TreeViewDemo.css\", \"../common/models/TreeViewModel.js\"],\n    // Data model\n    model: _TreeViewModel2.default,\n    // Property of the model containing children\n    category: \"items\",\n    selection: [],\n    // On selection, update the selection array\n    onselect: function onselect(items) {\n        _this.options.selection = items;\n        _this.update();\n    },\n    // Custom display\n    displaytag: function displaytag(item) {\n        return \"wrapped-label\";\n    },\n    // Alphabetical sort\n    sort: function sort(a, b) {\n        return a.label.localeCompare(b.label);\n    },\n    // Search bu regex\n    search: function search(input) {\n        return function (i) {\n            return (0, _tools.string)(i.label).contains(input);\n        };\n    },\n    strategies: {\n        // Use keyboard modifiers\n        selection: [\"modifiers\"],\n        // Use the opener to control element folding\n        fold: [\"opener-control\"]\n    },\n    // Custom css root class name\n    css: { TreeView: \"TreeViewDemo\" },\n    dragndrop: _extends({}, _dragndrop.dragndrop.selection(function () {\n        return _this.options.model;\n    }, function (m) {\n        _this.options.model = m;_this.update();\n    }), {\n        // Add a custom image on drag\n        drag: function drag(_, event) {\n            event.dataTransfer.setDragImage(_this.dragImage, 0, 0);\n            event.dataTransfer.setData(\"application/json\", JSON.stringify(_this.options.selection));\n        },\n        // Drop only on categories or root (excluding asynchronous promises)\n        droppable: function droppable(_) {\n            return !_ || _.items && _.items instanceof Array;\n        }\n    }),\n    transition: {\n        name: \"TreeViewDemoTransition\"\n    }\n};\nthis.updateSelection = function (item) {\n    return function (event) {\n        _this.options.selection = _this.options.selection.filter(function (_) {\n            return _ !== item;\n        });\n    };\n};\n});\n\n    \n  \n\n/***/ }),\n\n/***/ 591:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ 94:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* Riot v3.6.3, @license MIT */\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['ref', 'data-ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar RIOT_EVENTS_KEY = '__riot-events__';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar SVG_NS = 'http://www.w3.org/2000/svg';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_EVENTS_PREFIX = /^on/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check if the passed argument is a boolean attribute\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n\nvar check = Object.freeze({\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return Array.prototype.slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Check if a DOM node is an svg tag\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  return !!el.ownerSVGElement\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - true if we need to use an svg node\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom['hidden'] = show ? false : true;\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html) { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tisSvg: isSvg,\n\tmkEl: mkEl,\n\tsetInnerHTML: setInnerHTML,\n\ttoggleVisibility: toggleVisibility,\n\tremAttr: remAttr,\n\tstyleObjectToString: styleObjectToString,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\n// Create cache and shortcut to the correct property\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = ((function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  }))();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function (k) { return byName[k]; })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){  }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){  }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; ++i) {\n    fn(list[i], i);\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj;\n  var args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar settings$1 = extend(Object.create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n});\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent;\n  var item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings$1.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName;\n  var cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var tag = expr.tag || expr.dom._tag,\n    ref;\n\n  var ref$1 = tag ? tag.__ : {};\n  var head = ref$1.head;\n  var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n  if (tag && expr.tagName === tagName) {\n    tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    tag.unmount(true);\n  }\n\n  // unable to get the tag name\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n\n  // unknown implementation\n  if (!expr.impl) { return }\n\n  expr.tag = tag = initChildTag(\n    expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    },\n    expr.dom.innerHTML,\n    parent\n  );\n\n  each(expr.attrs, function (a) { return setAttr(tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  tag.mount();\n\n  // root exist first time, after use placeholder\n  if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function() {\n    var delName = tag.opts.dataIs;\n    arrayishRemove(tag.parent.tags, delName, tag);\n    arrayishRemove(tag.__.parent.tags, delName, tag);\n    tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttr(this.root,'virtualized')) { return }\n\n  var dom = expr.dom,\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n    isClassAttr = attrName === 'class',\n    hasValue,\n    isObj,\n    value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.__.wasCreated) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  // ...it seems to be a simple expression so we try to calculat its value\n  value = tmpl(expr.expr, isToggle ? extend({}, Object.create(this.parent), this) : this);\n  hasValue = !isBlank(value);\n  isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    isObj = !isClassAttr && !isStyleAttr;\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.isAttrRemoved || !hasValue || value === false)) {\n    remAttr(dom, expr.attr);\n    expr.isAttrRemoved = true;\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object we can not do much more with it\n  if (isObj && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (isBlank(value)) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    }\n\n    if (hasValue && value !== false) {\n      setAttr(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = createDOMPlaceholder();\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttr(this.dom, this.attr, this.value);\n      }\n    } else {\n      remAttr(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length;\n  var j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE);\n  var tagName = getTagName(dom);\n  var impl = __TAG_IMPL[tagName];\n  var parentNode = dom.parentNode;\n  var placeholder = createDOMPlaceholder();\n  var child = getTag(dom);\n  var ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE);\n  var tags = [];\n  var isLoop = true;\n  var isAnonymous = !__TAG_IMPL[tagName];\n  var isVirtual = dom.tagName === 'VIRTUAL';\n  var oldItems = [];\n  var hasKeys;\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var items = expr.value;\n    var frag = createFrag();\n    var isObject$$1 = !isArray(items) && !isString(items);\n    var root = placeholder.parentNode;\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function (item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function (item, i) {\n      // reorder only if the items are objects\n      var doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys;\n      var oldPos = oldItems.indexOf(item);\n      var isNew = oldPos === -1;\n      var pos = !isNew && doReorder ? oldPos : i;\n      // does a tag exist in this position?\n      var tag = tags[pos];\n      var mustAppend = i >= oldItems.length;\n      var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (mustCreate) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag.__.item = item;\n      tag.__.index = i;\n      tag.__.parent = parent;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function () {\n    each(tags, function (t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType,\n      parent = ctx.parent,\n      attr,\n      expr,\n      tagImpl;\n\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({\n          isRtag: true,\n          expr: expr,\n          dom: dom,\n          attrs: [].slice.call(dom.attributes)\n        });\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if(isVirtual) {\n      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttr(dom, 'virtualized', true);\n        var tag = new Tag$1(\n          {tmpl: dom.outerHTML},\n          {root: dom, parent: this$1},\n          dom.innerHTML\n        );\n        parent.children.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        parent.children.push(\n          initChildTag(\n            tagImpl,\n            {\n              root: dom,\n              parent: this$1\n            },\n            dom.innerHTML,\n            this$1\n          )\n        );\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name;\n    var bool = isBoolAttr(name);\n    var expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\nvar SVG = 'svg';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg$$1) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n  var  tagName = match && match[1].toLowerCase();\n  var el = mkEl(isSvg$$1 ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE), tag;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister$1(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version$1 = 'v3.6.3';\n\n\nvar core = Object.freeze({\n\tTag: Tag$2,\n\ttag: tag$1,\n\ttag2: tag2$1,\n\tmount: mount$1,\n\tmixin: mixin$1,\n\tupdate: update$1,\n\tunregister: unregister$1,\n\tversion: version$1\n});\n\n// counter to give a unique id to all the Tag instances\nvar uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n/**\n * Toggle the isMounted flag\n * @this Tag\n * @param { Boolean } value - ..of the isMounted flag\n */\nfunction setIsMounted(value) {\n  defineProperty(this, 'isMounted', value);\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = !!conf.isAnonymous,\n    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n    item = conf.item,\n    index = conf.index, // available only for the looped nodes\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    isInline = !isVirtual && !impl.tmpl,\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable$1(this); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  setIsMounted.call(this, false);\n\n  defineProperty(this, '__', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    wasCreated: false,\n    tail: null,\n    head: null,\n    parent: null,\n    item: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++uid); // base 1 allows test !t._riot_id\n  defineProperty(this, 'root', root);\n  extend(this, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    var nextOpts = {},\n      canTrigger = this.isMounted && !skipAnonymous;\n\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n    if (\n      canTrigger &&\n      this.isMounted &&\n      isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)\n    ) {\n      return this\n    }\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(opts, nextOpts);\n    if (canTrigger) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (canTrigger) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance, obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin && !skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    if (!skipAnonymous) { this.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n    this.update(item);\n\n    if (!isAnonymous && !isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    defineProperty(this, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!skipAnonymous && this.parent) {\n      var p = getImmediateCustomParentTag(this.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setIsMounted.call(this$1, true);\n        this$1.trigger('mount');\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setIsMounted.call(this, true);\n      if (!skipAnonymous) { this.trigger('mount'); }\n    }\n\n    this.__.wasCreated = true;\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root;\n    var p = el.parentNode;\n    var tagIndex = __TAGS_CACHE.indexOf(this);\n    var ptag;\n\n    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      remAttr(root, name);\n    });\n\n    // remove all the event listeners\n    this.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (tagIndex !== -1)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p || isVirtual) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          // remove from _parent too\n          if(parent !== ptag) {\n            arrayishRemove(parent.tags, tagName, this);\n          }\n        }\n      } else {\n        // remove the tag contents\n        setInnerHTML(el, '');\n      }\n\n      if (p && !mustKeepRoot) { p.removeChild(el); }\n    }\n\n    if (this.__.virts) {\n      each(this.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // custom internal unmount function to avoid relying on the observable\n    if (this.__.onUnmount) { this.__.onUnmount(); }\n\n    if (!skipAnonymous) {\n      // weird fix for a weird edge case #2409\n      if (!this.isMounted) { this.trigger('mount'); }\n      this.trigger('unmount');\n      this.off('*');\n    }\n\n    defineProperty(this, 'isMounted', false);\n    this.__.wasCreated = false;\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent;\n  var tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML);\n  var tagName = opts.tagName || getTagName(opts.root, true);\n  var ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function (expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom);\n  var namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n    namedTag : child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName];\n  var implClass = __TAG_IMPL[tagName].class;\n  var tag = ctx || (implClass ? Object.create(implClass.prototype) : {});\n  // cache the inner HTML to fix #855\n  var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFrag();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder();\n  var tail = createDOMPlaceholder();\n  var frag = createFrag();\n  var sib;\n  var el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head, sib;\n  var frag = createFrag();\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tmountTo: mountTo,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = settings$1;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag = Tag$2;\nvar tag = tag$1;\nvar tag2 = tag2$1;\nvar mount = mount$1;\nvar mixin = mixin$1;\nvar update = update$1;\nvar unregister = unregister$1;\nvar version = version$1;\nvar observable = observable$1;\n\nvar riot$1 = extend({}, core, {\n  observable: observable$1,\n  settings: settings,\n  util: util,\n});\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag;\nexports.tag = tag;\nexports.tag2 = tag2;\nexports.mount = mount;\nexports.mixin = mixin;\nexports.update = update;\nexports.unregister = unregister;\nexports.version = version;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ })\n\n},[585]);\n\n\n// WEBPACK FOOTER //\n// riot/build/riot.js","import riot from \"riot\"\nimport \"bosket/riot\"\nimport \"./components\"\n\nwindow.onload = () => {\n    riot.mount(\"*\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./docs/riot/index.js","!function(t,n){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=n(require(\"riot\"));else if(\"function\"==typeof define&&define.amd)define([\"riot\"],n);else{var e=n(\"object\"==typeof exports?require(\"riot\"):t.riot);for(var r in e)(\"object\"==typeof exports?exports:t)[r]=e[r]}}(this,function(t){return function(t){function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var e={};return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p=\"\",n(n.s=8)}([function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});var r=e(3);e.d(n,\"array\",function(){return r.a});var i=e(11);e.d(n,\"tree\",function(){return i.a});var o=e(12);e.d(n,\"string\",function(){return o.a});var s=e(13);e.d(n,\"deepMix\",function(){return s.a});var a=e(14);e.d(n,\"css\",function(){return a.a});var u=e(15);e.d(n,\"printer\",function(){return u.a});var c=e(16);e.d(n,\"object\",function(){return c.a})},function(n,e){n.exports=t},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});var r=e(18);Object.keys(r).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(n,t,{enumerable:!0,get:function(){return r[t]}})});var i=e(19);Object.keys(i).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(n,t,{enumerable:!0,get:function(){return i[t]}})});var o=e(20);Object.keys(o).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(n,t,{enumerable:!0,get:function(){return o[t]}})})},function(t,n,e){\"use strict\";e.d(n,\"a\",function(){return r});var r=function(t){return{last:function(){return t.length>0?t[t.length-1]:null},in:function(n,e){return t.filter(function(t){return n.indexOf(t)>=0&&(!e||e(t))})},notIn:function(n,e){return t.filter(function(t){return n.indexOf(t)<0&&(!e||e(t))})},is:function(n,e){var r=n.isIn,i=void 0===r?[]:r,o=n.notIn,s=void 0===o?[]:o;return t.filter(function(t){return i.reduce(function(n,e){return e.indexOf(t)>=0&&n},!0)&&s.reduce(function(n,e){return e.indexOf(t)<0&&n},!0)&&(!e||e(t))})},contains:function(n){return t.indexOf(n)>=0},allIn:function(n){return t.every(function(t){return n.indexOf(t)>=0})}}}},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});var r=e(17);e.d(n,\"TreeNode\",function(){return r.b}),e.d(n,\"RootNode\",function(){return r.a});var i=e(6);e.d(n,\"selectionStrategies\",function(){return i.c}),e.d(n,\"clickStrategies\",function(){return i.a}),e.d(n,\"foldStrategies\",function(){return i.b});var o=e(7);e.d(n,\"defaults\",function(){return o.a});var s=e(5);e.d(n,\"dragndrop\",function(){return s.a}),e.d(n,\"utils\",function(){return s.c}),e.d(n,\"nodeEvents\",function(){return s.b}),e.d(n,\"wrapEvents\",function(){return s.d})},function(t,n,e){\"use strict\";function r(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)}e.d(n,\"a\",function(){return s}),e.d(n,\"c\",function(){return u}),e.d(n,\"b\",function(){return f}),e.d(n,\"d\",function(){return d});var i=e(0),o=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t},s={selection:function(t,n){return{draggable:!0,droppable:!0,drag:function(t,n,e){n.dataTransfer&&n.dataTransfer.setData(\"application/json\",JSON.stringify(e.selection))},guard:function(t,n,e){if(n&&n.dataTransfer&&n.dataTransfer.types.indexOf(\"application/json\")<0)return!1;return function(){return t&&Object(i.array)(e.selection).contains(t)}()||function(){return e.ancestors&&e.ancestors.reduce(function(t,n){return t||Object(i.array)(e.selection).contains(n)},!1)}()},drop:function(e,o,s){var a=Object(i.tree)(t(),s.category).filter(function(t){return s.selection.indexOf(t)<0}),u=e?e[s.category]&&e[s.category]instanceof Array?e:Object(i.array)(s.ancestors).last():null;u?u[s.category]=[].concat(r(u[s.category]),r(s.selection)):a=[].concat(r(a),r(s.selection)),n(a)}}},pluck:function(t,n){return{draggable:!0,backup:[],drag:function(e,r,o){a=JSON.stringify(t()),r.dataTransfer&&r.dataTransfer.setData(\"application/json\",JSON.stringify(e)),setTimeout(function(){return n(Object(i.tree)(t(),o.category).filter(function(t){return t!==e}))},20)},cancel:function(){n(JSON.parse(a))}}},paste:function(t,n){return{droppable:!0,drop:function(e,o,s){if(o.dataTransfer&&o.dataTransfer.types.indexOf(\"application/json\")>-1){var a=JSON.parse(o.dataTransfer.getData(\"application/json\")),u=[].concat(r(t())),c=e?e[s.category]&&e[s.category]instanceof Array?e:Object(i.array)(s.ancestors).last():null;c?c[s.category]=[].concat(r(c[s.category]),[a]):u=[].concat(r(u),[a]),n(u)}}}}},a=\"[]\",u={filesystem:function(t){var n=t.dataTransfer?t.dataTransfer.items:null;if(n&&n.length>0&&\"file\"===n[0].kind){for(var e=[],r=0;r<n.length;r++){var i=n[r].webkitGetAsEntry()||n[r].getAsFile();i&&e.push(i)}return e}return null}},c=!1,f={onDragStart:function(t){return function(n){n.stopPropagation(),this.inputs.get().dragndrop.onDrag(t,n,this.inputs.get())}},onDragOver:function(t){return function(n){n.preventDefault(),n.stopPropagation(),c||(c=!0,this.inputs.get().dragndrop.guard&&this.inputs.get().dragndrop.guard(t,n,this.inputs.get())?(n.dataTransfer&&(n.dataTransfer.dropEffect=\"none\"),i.css.addClass(n.currentTarget,this.mixCss(\"nodrop\"))):i.css.addClass(n.currentTarget,this.mixCss(\"dragover\")),requestAnimationFrame(function(){c=!1}))}},onDragEnter:function(t){return function(n){if(n.preventDefault(),n.stopPropagation(),t&&(this.hasChildren(t)||this.isAsync(t))&&i.css.hasClass(n.target,this.mixCss(\"opener\"))){var e=this.state.get().unfolded.filter(function(n){return n!==t});e.push(t),this.state.set({unfolded:e})}}},onDragLeave:function(t){t.stopPropagation(),i.css.removeClass(t.currentTarget,this.mixCss(\"dragover\")),i.css.removeClass(t.currentTarget,this.mixCss(\"nodrop\"))},onDrop:function(t){return function(n){n.stopPropagation(),i.css.removeClass(n.currentTarget,this.mixCss(\"dragover\")),i.css.removeClass(n.currentTarget,this.mixCss(\"nodrop\")),this.inputs.get().dragndrop.onDrop(t,n,this.inputs.get())}},onDragEnd:function(t){return function(n){n.stopPropagation(),n.dataTransfer&&\"none\"===n.dataTransfer.dropEffect&&this.inputs.get().dragndrop.onCancel(t,n,this.inputs.get())}}},d=function(){var t=this;return o({},this.inputs.get().dragndrop,{onDrag:function(n,e,r){Object(i.array)(t.inputs.get().selection).contains(n)||t.onSelect(n,r.ancestors,r.neighbours),t.outputs.onDrag&&t.outputs.onDrag(n,e,r)},onDrop:function(n,e,r){e.preventDefault(),t.outputs.onDrop&&t.outputs.onDrop(n,e,r)},onCancel:function(n,e,r){e.preventDefault(),e.dataTransfer&&\"none\"===e.dataTransfer.dropEffect&&t.outputs.onCancel&&t.outputs.onCancel(n,e,r)}})}},function(t,n,e){\"use strict\";function r(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)}e.d(n,\"c\",function(){return u}),e.d(n,\"a\",function(){return c}),e.d(n,\"b\",function(){return f});var i=e(0),o=function(){function t(t,n){var e=[],r=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(r=(s=a.next()).done)&&(e.push(s.value),!n||e.length!==n);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return e}return function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return t(n,e);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),s=function(t,n,e,r){return Object(i.array)(n).contains(t)?[]:[t]},a=function(t,n,e,r){var o=!1,s=n.filter(function(n){return o||(o=n===t),n!==t&&r.indexOf(n)<0});return!o&&t[this.inputs.get().category]&&t[this.inputs.get().category]instanceof Array&&Object(i.tree)(t[this.inputs.get().category],this.inputs.get().category).visit(function(t){s=Object(i.array)(s).notIn(t)}),o||s.push(t),s},u={single:s,multiple:a,modifiers:function(t,n,e,u){var c=this;if(this.modifiers.control||this.modifiers.meta)return this.lastSelection=t,delete this.lastIndex,delete this.lastPivot,a.bind(this)(t,n,e,u);if(this.modifiers.shift){if(!this.lastSelection)return n;var f=e.indexOf(this.lastSelection);if(f<0)return n;var d=n.slice(),l=e.indexOf(t);if(f>=0){var p;if(this.lastPivot){var g=e.indexOf(this.lastPivot),h=f>g?[g,f]:[f,g],v=o(h,2),y=v[0],b=v[1],m=e.slice(y,b+1);d=Object(i.array)(d).notIn(m)}this.lastPivot=t;var O=f>l?[l,f]:[f,l],x=o(O,2),D=x[0],j=x[1],w=this.inputs.get().disabled?e.slice(D,j+1).filter(function(t){return!c.inputs.get().disabled(t)}):e.slice(D,j+1);d=Object(i.array)(d).notIn(w),(p=d).push.apply(p,r(w))}return d}return this.lastSelection=t,delete this.lastIndex,delete this.lastPivot,s.bind(this)(t,n.length>1?[]:n,e,u)},ancestors:function(t){function n(n,e,r,i){return t.apply(this,arguments)}return n.toString=function(){return t.toString()},n}(function(t,n,e,o){return 0===n.length?[t]:Object(i.array)(n).contains(t)?[].concat(r(o)):[].concat(r(o),[t])})},c={\"unfold-on-selection\":function(t){if(!this.isSelected(t)){var n=this.state.get().unfolded.filter(function(n){return n!==t});n.push(t),this.state.set({unfolded:n})}},\"toggle-fold\":function(t){var n=this.state.get().unfolded.filter(function(n){return n!==t});n.length===this.state.get().unfolded.length&&n.push(t),this.state.set({unfolded:n})}},f={\"opener-control\":function(t){return!Object(i.array)(this.state.get().unfolded).contains(t)},\"not-selected\":function(t){return!this.isSelected(t)},\"no-child-selection\":function(t){var n=this;return!function t(e){return n.isSelected(e)||e[n.inputs.get().category]&&e[n.inputs.get().category]instanceof Array&&e[n.inputs.get().category].some(t)}(t)},\"max-depth\":function(){return!(!this.inputs.get().maxDepth||isNaN(parseInt(this.inputs.get().maxDepth,10)))&&this.inputs.get().depth>=parseInt(this.inputs.get().maxDepth,10)}}},function(t,n,e){\"use strict\";e.d(n,\"a\",function(){return r});var r={labels:{\"search.placeholder\":\"Search ...\"},css:{TreeView:\"TreeView\",opener:\"opener\",depth:\"depth\",selected:\"selected\",category:\"category\",folded:\"folded\",disabled:\"disabled\",async:\"async\",loading:\"loading\",nodrop:\"nodrop\",dragover:\"dragover\",search:\"search\",item:\"item\"},strategies:{selection:[\"single\"],click:[],fold:[\"not-selected\",\"no-child-selection\"]},display:function(t){return t.toString()},async:function(t){return t()},noOpener:!1,dragndrop:{draggable:!1,droppable:!1}}},function(t,n,e){\"use strict\";e(9)},function(t,n,e){\"use strict\";e(10),e(21),e(22)},function(t,n,e){e(1).tag2(\"treeview\",'<div class=\"{rootNode.mixCss(⁗TreeView⁗)}\"> <input type=\"search\" class=\"{rootNode.mixCss(⁗search⁗)}\" if=\"{inputs.get().search}\" placeholder=\"{inputs.get().labels[⁗search.placeholder⁗]}\" onkeyup=\"{onSearch}\"> <treeviewnode opts=\"{inputs.get()}\" model=\"{inputs.get().sort ? inputs.get().model.sort(inputs.get().sort) : inputs.get().model}\" filteredmodel=\"{filtered}\" onselect=\"{rootNode.onSelect}\" dragndrop=\"{rootNode.wrapDragNDrop()}\" ancestors=\"{[]}\" searched=\"{search.trim()}\" depth=\"{+⁗0⁗}\"> </TreeViewNode> </div>',\"\",\"\",function(t){\"use strict\";var n=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t},r=this,i=e(0),o=e(4),s=e(2);this.mixin((0,s.optsMixin)()),this.mixin((0,s.listenerMixin)({eventType:\"keyup\",callback:function(t){return r.rootNode.onKey(t)},autoMount:!0})),this.mixin((0,s.listenerMixin)({eventType:\"keydown\",callback:function(t){return r.rootNode.onKey(t)},autoMount:!0})),this.filtered=null,this.search=\"\",this.onSearch=function(t){var n=t.currentTarget.value;r.search=n,r.filtered=n.trim()?(0,i.tree)(r.inputs.get().model,r.inputs.get().category).treeFilter(r.inputs.get().search(n.trim())):null},this.inputs={get:function(){return n({},o.defaults,r.opts,{onSelect:r.opts.onselect})}},this.outputs={onSelect:this.inputs.get().onselect,onDrag:this.inputs.get().dragndrop&&this.inputs.get().dragndrop.drag,onDrop:this.inputs.get().dragndrop&&this.inputs.get().dragndrop.drop,onCancel:this.inputs.get().dragndrop&&this.inputs.get().dragndrop.cancel},this.state={get:function(){return n({},r)},set:function(t){for(var n in t)n in r&&(r[n]=t[n])}},this.rootNode=new o.RootNode(this.inputs,this.outputs,this.state,this.update)})},function(t,n,e){\"use strict\";function r(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)}e.d(n,\"a\",function(){return o});var i=e(3),o=function(t,n){return{flatten:function(){for(var e=[],o=[t];o.length>0;){var s=o.pop();s instanceof Array&&(e=[].concat(r(Object(i.a)(e).notIn(s)),r(s)),o=[].concat(r(o),r(s.filter(function(t){return t[n]}).map(function(t){return t[n]}))))}return e},filter:function(e){var r=t.filter(e);return function t(r){r.forEach(function(r){r[n]&&r[n]instanceof Array&&(r[n]=r[n].filter(e),t(r[n]))})}(r),r},treeFilter:function(e){var r=new Map;return function t(r,i){r.forEach(function(r){if(r[n]&&r[n]instanceof Array){var o=new Map;t(r[n],o),o.size>0?i.set(r,o):e(r)&&i.set(r,new Map)}else e(r)&&i.set(r,null)})}(t,r),r},add:function(e,i){for(var o=[t];o.length>0;){var s=o.pop(),a=s.indexOf(e);if(a>=0&&s[a][n])return s[a][n]=s[a][n].slice(),s[a][n].push(i),t;o=[].concat(r(o),r(s.filter(function(t){return t[n]}).map(function(t){return t[n]})))}return t},visit:function(e){for(var r=[t];r.length>0;){var i=r.pop();e(i),i.forEach(function(t){return t[n]&&t[n]instanceof Array?r.push(t[n]):null})}}}}},function(t,n,e){\"use strict\";e.d(n,\"a\",function(){return r});var r=function(t){return{contains:function(n){return!!t&&!!t.match(new RegExp(\".*\"+n+\".*\",\"gi\"))}}}},function(t,n,e){\"use strict\";function r(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)}e.d(n,\"a\",function(){return s});var i=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t},o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},s=function t(n,e){var s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!n||!e||\"object\"!==(void 0===n?\"undefined\":o(n))||\"object\"!==(void 0===e?\"undefined\":o(e)))return n;var a=i({},n,e);for(var u in e)e.hasOwnProperty(u)&&(e[u]instanceof Array&&n[u]instanceof Array?a[u]=s?[].concat(r(n[u]),r(e[u])):a[u]=e[u]:\"object\"===o(e[u])&&\"object\"===o(n[u])&&(a[u]=t(n[u],e[u],s)));return a}},function(t,n,e){\"use strict\";e.d(n,\"a\",function(){return r});var r={classes:function(t){var n=[];for(var e in t)t[e]&&n.push(e);return n.join(\" \")},addClass:function(t,n){t instanceof HTMLElement&&(t.className=t.className.split(\" \").filter(function(t){return t!==n}).join(\" \")+\" \"+n)},removeClass:function(t,n){t instanceof HTMLElement&&(t.className=t.className.split(\" \").filter(function(t){return t!==n}).join(\" \"))},hasClass:function(t,n){return t instanceof HTMLElement&&t.className.indexOf(n)>=0}}},function(t,n,e){\"use strict\";e.d(n,\"a\",function(){return r});var r={debug:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;e(\"%cDEBUG%c \"+t,\"background-color: red; color: white; font-size: 1.1em; font-weight: bold; padding: 3px 10px; border-radius: 5px\",\"color: #444; font-weight: bold; font-size: 1.1em\"),e(\"%c\"+n,\"color: #222; font-weight: bold\")}}},function(t,n,e){\"use strict\";function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}e.d(n,\"a\",function(){return o});var i=function(){function t(t,n){var e=[],r=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(r=(s=a.next()).done)&&(e.push(s.value),!n||e.length!==n);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return e}return function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return t(n,e);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),o=function(t){if(!(t&&t instanceof Object))throw new Error(\"Bad object format\");return{shallowCompare:function(n,e){var r=!0;for(var i in t)if(t.hasOwnProperty(i)&&!(e&&e.indexOf(i)>=0)&&n[i]!==t[i])return void(r=!1);return r},filter:function(n){var e={};for(var r in t)t.hasOwnProperty(r)&&n(t[r])&&(e[r]=t[r]);return e},map:function(n){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=n(t[r]));return e},fullMap:function(n){var e={};for(var r in t)if(t.hasOwnProperty(r)){var o=n(r,t[r]),s=i(o,2),a=s[0],u=s[1];e[a]=u}return e},nestPrefix:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(t){return t},i=r({},n,{});for(var o in t)t.hasOwnProperty(o)&&o.startsWith(n)?i[n][e(o.substring(n.length))]=t[o]:i[o]=t[o];return i}}}},function(t,n,e){\"use strict\";function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!n||\"object\"!=typeof n&&\"function\"!=typeof n?t:n}function o(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof n);t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(t,n):t.__proto__=n)}function s(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}e.d(n,\"b\",function(){return p}),e.d(n,\"a\",function(){return g});var a=e(0),u=e(5),c=e(6),f=e(7),d=function(){function t(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(n,e,r){return e&&t(n.prototype,e),r&&t(n,r),n}}(),l=function t(n,e,r,i){s(this,t),this.inputs=n,this.outputs=e,this.state=r,this.refresh=i},p=function(t){function n(){var t,e,o,d;s(this,n);for(var l=arguments.length,p=Array(l),g=0;g<l;g++)p[g]=arguments[g];return e=o=i(this,(t=n.__proto__||Object.getPrototypeOf(n)).call.apply(t,[this].concat(p))),o.isSelected=function(t){return Object(a.array)(o.inputs.get().selection).contains(t)},o.isFolded=function(t){var n=o.inputs.get().strategies;return(!o.inputs.get().searched||o.isAsync(t))&&(n&&n.fold||[]).map(function(t){return(c.b[t]||t).bind(o)}).reduce(function(n,e){return n&&e(t,n)},!0)},o.hasChildren=function(t){return t[o.inputs.get().category]&&t[o.inputs.get().category]instanceof Array},o.isAsync=function(t){return!!t&&[o.inputs.get().category]&&\"function\"==typeof t[o.inputs.get().category]},o.isDisabled=function(t){var n=o.inputs.get().disabled;return!!n&&n(t)},o.isDraggable=function(t){return t&&o.inputs.get().dragndrop.draggable&&(\"function\"!=typeof o.inputs.get().dragndrop.draggable||o.inputs.get().dragndrop.draggable(t))},o.isDroppable=function(t){return o.inputs.get().dragndrop.droppable&&(\"function\"!=typeof o.inputs.get().dragndrop.droppable||o.inputs.get().dragndrop.droppable(t))},o.mixCss=function(t){return o.inputs.get().css[t]||f.a.css[t]},o.ulCss=function(){return a.css.classes(r({},o.mixCss(\"depth\")+\"-\"+(o.inputs.get().depth||0),!0))},o.liCss=function(t){var n;return a.css.classes((n={},r(n,o.mixCss(\"selected\"),o.isSelected(t)),r(n,o.mixCss(\"category\"),o.hasChildren(t)||o.isAsync(t)),r(n,o.mixCss(\"folded\"),o.hasChildren(t)||o.isAsync(t)?o.isFolded(t):null),r(n,o.mixCss(\"disabled\"),o.isDisabled(t)),r(n,o.mixCss(\"async\"),o.isAsync(t)&&o.isFolded(t)),r(n,o.mixCss(\"loading\"),o.isAsync(t)&&!o.isFolded(t)),n))},o.pending=[],o.unwrapPromise=function(t){o.pending.push(t);var n=o.inputs.get().async;return n?n(t[o.inputs.get().category]).then(function(n){t[o.inputs.get().category]=n,o.refresh()}).catch(function(t){throw t}).then(function(){return o.pending=o.pending.filter(function(n){return n!==t})}):Promise.reject(new Error(\"Missing async function.\"))},o.onClick=function(t){return function(n){if(!o.isDisabled(t)){var e=o.inputs.get().strategies;(e&&e.click||[]).map(function(t){return(c.a[t]||t).bind(o)}).forEach(function(e){return e(t,n,o.inputs.get().ancestors,o.inputs.get().model)}),o.inputs.get().onSelect(t,o.inputs.get().ancestors,o.inputs.get().model),n.stopPropagation()}}},o.getDragEvents=function(t){if(arguments.length>1&&void 0!==arguments[1]&&!arguments[1])return{};var n={draggable:o.isDraggable(t),onDragStart:o.isDraggable(t)&&u.b.onDragStart(t).bind(o),onDragOver:o.isDroppable(t)&&u.b.onDragOver(t).bind(o),onDragEnter:o.isDroppable(t)&&u.b.onDragEnter(t).bind(o),onDragLeave:o.isDroppable(t)&&u.b.onDragLeave.bind(o),onDrop:o.isDroppable(t)&&u.b.onDrop(t).bind(o),onDragEnd:o.isDraggable(t)&&u.b.onDragEnd(t).bind(o)};for(var e in n)n[e]||delete n[e];return n},d=e,i(o,d)}return o(n,t),d(n,[{key:\"onOpener\",value:function(t){var n=this;return function(e){var r=n.state.get().unfolded.filter(function(n){return n!==t});r.length===n.state.get().unfolded.length&&r.push(t),n.state.set({unfolded:r}),e.stopPropagation()}}}]),n}(l),g=function(t){function n(){var t,e,r,o;s(this,n);for(var d=arguments.length,l=Array(d),p=0;p<d;p++)l[p]=arguments[p];return e=r=i(this,(t=n.__proto__||Object.getPrototypeOf(n)).call.apply(t,[this].concat(l))),r.modifiers={},r.onKey=function(t){r.modifiers={control:t.getModifierState(\"Control\"),meta:t.getModifierState(\"Meta\"),shift:t.getModifierState(\"Shift\")}},r.onSelect=function(t,n,e){var i=r.inputs.get().strategies.selection||[],o=i.map(function(t){return(c.c[t]||t).bind(r)}).reduce(function(r,i){return i(t,r,e,n)},r.inputs.get().selection);return r.outputs.onSelect(o,t,n,e),o},r.wrapDragNDrop=u.d.bind(r),r.mixCss=function(t){return r.inputs.get().css[t]||f.a.css[t]},r.filterTree=function(t){var n=r.inputs.get().search;return n&&t.trim()?Object(a.tree)(r.inputs.get().model,r.inputs.get().category).treeFilter(n(t.trim())):null},o=e,i(r,o)}return o(n,t),n}(l)},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});n.optsMixin=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"opts\";return{init:function(){this.on(\"update\",this.updateOpts),this._originalOpts=Object.keys(this.opts),this.updateOpts()},updateOpts:function(){if(this.opts)for(var n in this.opts[t])~this._originalOpts.indexOf(n)||(this.opts[n]=this.opts[t][n])}}}},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});n.transitionMixin=function(t){return{init:function(){var n=this;if(\"transition\"in this.opts){var e=this.opts.transition.name,r=this.unmount,i=function(){var r=(t||function(){return n.root})();r&&(r.classList.add(e),r.classList.add(e+\"-mount\"),setTimeout(function(){r.classList.remove(e+\"-mount\")},10))},o=!1,s=function(){if(!o){o=!0;var i=(t||function(){return n.root})();if(!i)return r.call(n);i.addEventListener(\"transitionend\",function(){r.call(n)}),i.classList.add(e+\"-unmount\")}};this.one(\"mount\",i),Object.defineProperty(this,\"unmount\",{value:s})}}}}},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});n.listenerMixin=function(t){var n=t.eventType,e=void 0===n?\"click\":n,r=t.callback,i=t.regulate,o=void 0!==i&&i;return{init:function(){var t=!1,n=function(n){r&&(o?(t||window.requestAnimationFrame(function(){return r(n,function(){return t=!1})}),t=!0):r(n))};this.one(\"mount\",function(){document.addEventListener(e,n)}),this.one(\"unmount\",function(){document.removeEventListener(e,n)})}}}},function(t,n,e){e(1).tag2(\"treeviewnode\",'<ul if=\"{!opts.folded && !opts.loading}\" data-is=\"with-transition\" transition=\"{opts.transition}\" class=\"{node.ulCss()}\" ondragover=\"{!opts.depth ? rootEvents.onDragOver : null}\" ondragenter=\"{!opts.depth ? rootEvents.onDragEnter : null}\" ondragleave=\"{!opts.depth ? rootEvents.onDragLeave : null}\" ondrop=\"{!opts.depth ? rootEvents.onDrop : null}\"> <li each=\"{item in getModel()}\" class=\"{node.liCss(item)}\" draggable=\"{node.getDragEvents(item).draggable}\" ondragstart=\"{node.getDragEvents(item).onDragStart}\" ondragover=\"{node.getDragEvents(item).onDragOver}\" ondragenter=\"{node.getDragEvents(item).onDragEnter}\" ondragleave=\"{node.getDragEvents(item).onDragLeave}\" ondragend=\"{node.getDragEvents(item).onDragEnd}\" ondrop=\"{node.getDragEvents(item).onDrop}\"> <span class=\"{parent.node.mixCss(⁗item⁗)}\" onclick=\"{parent.node.onClick(item)}\"> <virtual if=\"{!parent.opts.displaytag}\"> {parent.opts.display(item, parent.opts)} </virtual> <virtual if=\"{parent.opts.displaytag}\" data-is=\"{parent.opts.displaytag(item, parent.opts)}\" item=\"{item}\"></virtual> <span if=\"{node.hasChildren(item) || node.isAsync(item) && !parent.opts.noopener}\" class=\"{node.mixCss(⁗opener⁗)}\" onclick=\"{node.onOpener(item)}\"></span> </span> <treeviewnode if=\"{node.hasChildren(item) || node.isAsync(item)}\" opts=\"{parent.opts}\" model=\"{getChildModel(item)}\" filteredmodel=\"{getChildFiltered(item)}\" ancestors=\"{getAncestors(item)}\" depth=\"{parent.opts.depth + 1}\" folded=\"{node.isFolded(item)}\" loading=\"{node.isAsync(item) && !node.isFolded(item)}\"> </TreeViewNode> </li> </ul> <span if=\"{opts.loading}\"></span>',\"\",\"\",function(t){\"use strict\";var n=this,r=e(4),i=e(2);this.mixin((0,i.optsMixin)()),this.unfolded=[],this.getModel=function(){return n.opts.searched?n.opts.model.filter(function(t){return n.opts.filteredmodel.has(t)}):n.opts.model},this.getChildModel=function(t){var e=t[n.opts.category];return n.node.isAsync(t)&&!n.node.isFolded(t)&&n.node.pending.indexOf(t)<0&&n.node.unwrapPromise(t),n.node.isAsync(t)||(e=n.opts.sort?e.sort(n.opts.sort):e),e},this.getChildFiltered=function(t){return n.opts.searched?n.opts.filteredmodel.get(t):null},this.getAncestors=function(t){return[].concat(n.opts.ancestors,[t])};var o=function(){n.opts.onSelect=n.opts.onselect};this.on(\"update\",o),o(),this.inputs={get:function(){return n.opts}},this.state={get:function(){return n},set:function(t){for(var e in t)e in n&&(n[e]=t[e])}},this.node=new r.TreeNode(this.inputs,null,this.state,this.update),this.rootEvents=this.node.getDragEvents()})},function(t,n,e){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0});var r=e(1),i=function(t){return t&&t.__esModule?t:{default:t}}(r),o=e(2);n.default=i.default.tag(\"with-transition\",!1,function(t){var n=this;this.mixin((0,o.transitionMixin)());var e=function(){for(var t in n.parent)n.parent.hasOwnProperty(t)&&(n[t]=n.parent[t])};e(),this.on(\"update\",e)})}])});\n//# sourceMappingURL=index.js.map\n\n\n// WEBPACK FOOTER //\n// ./build/riot/index.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 587\n// module chunks = 3","import \"./App.tag\"\nimport \"./Demos/TreeView/TreeViewDemo.tag\"\n\n\n\n// WEBPACK FOOTER //\n// ./docs/riot/components/index.js","\n    var riot = require('riot')\n    riot.tag2('app', '<div class=\"App\"> <div class=\"chapter\"> <p> This page covers the <em class=\"highlight\"><a href=\"http://riotjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Riot.js</a></em> implementation of the <em><a href=\"../#Introduction\">Bosket library</a></em>.<br> Versatile and flexible, Bosket eases the creation and design of tree view components.<br><br> As a matter of fact <em><a href=\"https://github.com/elbywan/bosket/tree/master/docs/riot/plan\" target=\"_blank\" rel=\"noopener noreferrer\">this whole documentation</a></em> is built around Bosket using <em><a href=\"https://github.com/elbywan/bosket/blob/master/docs/riot/components/Planner.tag\" target=\"_blank\" rel=\"noopener noreferrer\">a custom component</a></em> which automatically creates the table of contents and the anchors.<br> <br> Multiple use case examples (including the source code and the css stylesheet) are provided alongside the documentation. </p> <treeviewdemo></treeviewdemo> </div> </div>', '', '', function(opts) {\n\"use strict\";\n\nrequire(\"self/common/styles/App.css\");\n});\n\n    \n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./docs/riot/components/App.tag\n// module id = 589\n// module chunks = 3","\n    var riot = require('riot')\n    riot.tag2('treeviewdemo', '<treeview opts=\"{options}\"></treeview> <p> <span if=\"{options.selection.length === 0}\">No elements are</span> <span if=\"{options.selection.length === 1}\">One element is</span> <span if=\"{options.selection.length > 1}\">{options.selection.length} elements are</span> selected. </p> <div class=\"select-blocks\"> <button each=\"{item in options.selection}\" onclick=\"{updateSelection(item)}\"> {item.label} </button> </div>', '', '', function(opts) {\n\"use strict\";\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _this = this;\n\n// Model\n\nvar _tools = require(\"bosket/tools\");\n\nvar _dragndrop = require(\"bosket/core/dragndrop\");\n\nvar _riot = require(\"riot\");\n\nvar _riot2 = _interopRequireDefault(_riot);\n\nvar _TreeViewModel = require(\"self/common/models/TreeViewModel\");\n\nvar _TreeViewModel2 = _interopRequireDefault(_TreeViewModel);\n\nrequire(\"./TreeViewDemo.css\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nthis.dragImage = new Image();\nthis.dragImage.src = \"../assets/drag-image.png\";\n\n_riot2.default.tag(\"wrapped-label\", \"<a>{ opts.item.label }</a>\");\n\nthis.options = {\n    files: [\"./components/Demos/TreeView/TreeViewDemo.js\", \"./components/Demos/TreeView/TreeViewDemo.css\", \"../common/models/TreeViewModel.js\"],\n    // Data model\n    model: _TreeViewModel2.default,\n    // Property of the model containing children\n    category: \"items\",\n    selection: [],\n    // On selection, update the selection array\n    onselect: function onselect(items) {\n        _this.options.selection = items;\n        _this.update();\n    },\n    // Custom display\n    displaytag: function displaytag(item) {\n        return \"wrapped-label\";\n    },\n    // Alphabetical sort\n    sort: function sort(a, b) {\n        return a.label.localeCompare(b.label);\n    },\n    // Search bu regex\n    search: function search(input) {\n        return function (i) {\n            return (0, _tools.string)(i.label).contains(input);\n        };\n    },\n    strategies: {\n        // Use keyboard modifiers\n        selection: [\"modifiers\"],\n        // Use the opener to control element folding\n        fold: [\"opener-control\"]\n    },\n    // Custom css root class name\n    css: { TreeView: \"TreeViewDemo\" },\n    dragndrop: _extends({}, _dragndrop.dragndrop.selection(function () {\n        return _this.options.model;\n    }, function (m) {\n        _this.options.model = m;_this.update();\n    }), {\n        // Add a custom image on drag\n        drag: function drag(_, event) {\n            event.dataTransfer.setDragImage(_this.dragImage, 0, 0);\n            event.dataTransfer.setData(\"application/json\", JSON.stringify(_this.options.selection));\n        },\n        // Drop only on categories or root (excluding asynchronous promises)\n        droppable: function droppable(_) {\n            return !_ || _.items && _.items instanceof Array;\n        }\n    }),\n    transition: {\n        name: \"TreeViewDemoTransition\"\n    }\n};\nthis.updateSelection = function (item) {\n    return function (event) {\n        _this.options.selection = _this.options.selection.filter(function (_) {\n            return _ !== item;\n        });\n    };\n};\n});\n\n    \n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./docs/riot/components/Demos/TreeView/TreeViewDemo.tag\n// module id = 590\n// module chunks = 3","/* Riot v3.6.3, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['ref', 'data-ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar RIOT_EVENTS_KEY = '__riot-events__';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar SVG_NS = 'http://www.w3.org/2000/svg';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_EVENTS_PREFIX = /^on/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check if the passed argument is a boolean attribute\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n\nvar check = Object.freeze({\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return Array.prototype.slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Check if a DOM node is an svg tag\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  return !!el.ownerSVGElement\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - true if we need to use an svg node\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom['hidden'] = show ? false : true;\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html) { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tisSvg: isSvg,\n\tmkEl: mkEl,\n\tsetInnerHTML: setInnerHTML,\n\ttoggleVisibility: toggleVisibility,\n\tremAttr: remAttr,\n\tstyleObjectToString: styleObjectToString,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\n// Create cache and shortcut to the correct property\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = ((function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  }))();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function (k) { return byName[k]; })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){  }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){  }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; ++i) {\n    fn(list[i], i);\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj;\n  var args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar settings$1 = extend(Object.create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n});\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent;\n  var item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings$1.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName;\n  var cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var tag = expr.tag || expr.dom._tag,\n    ref;\n\n  var ref$1 = tag ? tag.__ : {};\n  var head = ref$1.head;\n  var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n  if (tag && expr.tagName === tagName) {\n    tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    tag.unmount(true);\n  }\n\n  // unable to get the tag name\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n\n  // unknown implementation\n  if (!expr.impl) { return }\n\n  expr.tag = tag = initChildTag(\n    expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    },\n    expr.dom.innerHTML,\n    parent\n  );\n\n  each(expr.attrs, function (a) { return setAttr(tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  tag.mount();\n\n  // root exist first time, after use placeholder\n  if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function() {\n    var delName = tag.opts.dataIs;\n    arrayishRemove(tag.parent.tags, delName, tag);\n    arrayishRemove(tag.__.parent.tags, delName, tag);\n    tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttr(this.root,'virtualized')) { return }\n\n  var dom = expr.dom,\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n    isClassAttr = attrName === 'class',\n    hasValue,\n    isObj,\n    value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.__.wasCreated) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  // ...it seems to be a simple expression so we try to calculat its value\n  value = tmpl(expr.expr, isToggle ? extend({}, Object.create(this.parent), this) : this);\n  hasValue = !isBlank(value);\n  isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    isObj = !isClassAttr && !isStyleAttr;\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.isAttrRemoved || !hasValue || value === false)) {\n    remAttr(dom, expr.attr);\n    expr.isAttrRemoved = true;\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object we can not do much more with it\n  if (isObj && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (isBlank(value)) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    }\n\n    if (hasValue && value !== false) {\n      setAttr(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = createDOMPlaceholder();\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttr(this.dom, this.attr, this.value);\n      }\n    } else {\n      remAttr(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length;\n  var j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE);\n  var tagName = getTagName(dom);\n  var impl = __TAG_IMPL[tagName];\n  var parentNode = dom.parentNode;\n  var placeholder = createDOMPlaceholder();\n  var child = getTag(dom);\n  var ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE);\n  var tags = [];\n  var isLoop = true;\n  var isAnonymous = !__TAG_IMPL[tagName];\n  var isVirtual = dom.tagName === 'VIRTUAL';\n  var oldItems = [];\n  var hasKeys;\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var items = expr.value;\n    var frag = createFrag();\n    var isObject$$1 = !isArray(items) && !isString(items);\n    var root = placeholder.parentNode;\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function (item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function (item, i) {\n      // reorder only if the items are objects\n      var doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys;\n      var oldPos = oldItems.indexOf(item);\n      var isNew = oldPos === -1;\n      var pos = !isNew && doReorder ? oldPos : i;\n      // does a tag exist in this position?\n      var tag = tags[pos];\n      var mustAppend = i >= oldItems.length;\n      var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (mustCreate) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag.__.item = item;\n      tag.__.index = i;\n      tag.__.parent = parent;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function () {\n    each(tags, function (t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType,\n      parent = ctx.parent,\n      attr,\n      expr,\n      tagImpl;\n\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({\n          isRtag: true,\n          expr: expr,\n          dom: dom,\n          attrs: [].slice.call(dom.attributes)\n        });\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if(isVirtual) {\n      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttr(dom, 'virtualized', true);\n        var tag = new Tag$1(\n          {tmpl: dom.outerHTML},\n          {root: dom, parent: this$1},\n          dom.innerHTML\n        );\n        parent.children.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        parent.children.push(\n          initChildTag(\n            tagImpl,\n            {\n              root: dom,\n              parent: this$1\n            },\n            dom.innerHTML,\n            this$1\n          )\n        );\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name;\n    var bool = isBoolAttr(name);\n    var expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\nvar SVG = 'svg';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg$$1) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n  var  tagName = match && match[1].toLowerCase();\n  var el = mkEl(isSvg$$1 ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE), tag;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister$1(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version$1 = 'v3.6.3';\n\n\nvar core = Object.freeze({\n\tTag: Tag$2,\n\ttag: tag$1,\n\ttag2: tag2$1,\n\tmount: mount$1,\n\tmixin: mixin$1,\n\tupdate: update$1,\n\tunregister: unregister$1,\n\tversion: version$1\n});\n\n// counter to give a unique id to all the Tag instances\nvar uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n/**\n * Toggle the isMounted flag\n * @this Tag\n * @param { Boolean } value - ..of the isMounted flag\n */\nfunction setIsMounted(value) {\n  defineProperty(this, 'isMounted', value);\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = !!conf.isAnonymous,\n    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n    item = conf.item,\n    index = conf.index, // available only for the looped nodes\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    isInline = !isVirtual && !impl.tmpl,\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable$1(this); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  setIsMounted.call(this, false);\n\n  defineProperty(this, '__', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    wasCreated: false,\n    tail: null,\n    head: null,\n    parent: null,\n    item: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++uid); // base 1 allows test !t._riot_id\n  defineProperty(this, 'root', root);\n  extend(this, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    var nextOpts = {},\n      canTrigger = this.isMounted && !skipAnonymous;\n\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n    if (\n      canTrigger &&\n      this.isMounted &&\n      isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)\n    ) {\n      return this\n    }\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(opts, nextOpts);\n    if (canTrigger) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (canTrigger) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance, obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin && !skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    if (!skipAnonymous) { this.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n    this.update(item);\n\n    if (!isAnonymous && !isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    defineProperty(this, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!skipAnonymous && this.parent) {\n      var p = getImmediateCustomParentTag(this.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setIsMounted.call(this$1, true);\n        this$1.trigger('mount');\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setIsMounted.call(this, true);\n      if (!skipAnonymous) { this.trigger('mount'); }\n    }\n\n    this.__.wasCreated = true;\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root;\n    var p = el.parentNode;\n    var tagIndex = __TAGS_CACHE.indexOf(this);\n    var ptag;\n\n    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      remAttr(root, name);\n    });\n\n    // remove all the event listeners\n    this.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (tagIndex !== -1)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p || isVirtual) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          // remove from _parent too\n          if(parent !== ptag) {\n            arrayishRemove(parent.tags, tagName, this);\n          }\n        }\n      } else {\n        // remove the tag contents\n        setInnerHTML(el, '');\n      }\n\n      if (p && !mustKeepRoot) { p.removeChild(el); }\n    }\n\n    if (this.__.virts) {\n      each(this.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // custom internal unmount function to avoid relying on the observable\n    if (this.__.onUnmount) { this.__.onUnmount(); }\n\n    if (!skipAnonymous) {\n      // weird fix for a weird edge case #2409\n      if (!this.isMounted) { this.trigger('mount'); }\n      this.trigger('unmount');\n      this.off('*');\n    }\n\n    defineProperty(this, 'isMounted', false);\n    this.__.wasCreated = false;\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent;\n  var tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML);\n  var tagName = opts.tagName || getTagName(opts.root, true);\n  var ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function (expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom);\n  var namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n    namedTag : child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName];\n  var implClass = __TAG_IMPL[tagName].class;\n  var tag = ctx || (implClass ? Object.create(implClass.prototype) : {});\n  // cache the inner HTML to fix #855\n  var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFrag();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder();\n  var tail = createDOMPlaceholder();\n  var frag = createFrag();\n  var sib;\n  var el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head, sib;\n  var frag = createFrag();\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tmountTo: mountTo,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = settings$1;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag = Tag$2;\nvar tag = tag$1;\nvar tag2 = tag2$1;\nvar mount = mount$1;\nvar mixin = mixin$1;\nvar update = update$1;\nvar unregister = unregister$1;\nvar version = version$1;\nvar observable = observable$1;\n\nvar riot$1 = extend({}, core, {\n  observable: observable$1,\n  settings: settings,\n  util: util,\n});\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag;\nexports.tag = tag;\nexports.tag2 = tag2;\nexports.mount = mount;\nexports.mixin = mixin;\nexports.update = update;\nexports.unregister = unregister;\nexports.version = version;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/riot/riot.js\n// module id = 94\n// module chunks = 3"],"sourceRoot":""}