{"version":3,"sources":["../../src/tools/trees.js"],"names":["array","tree","prop","t","Array","Error","flatten","flattened","fifo","length","pop","notIn","filter","item","map","copy","filterFun","recurse","list","forEach","treeFilter","finalMap","Map","childMap","size","set","add","parent","elt","idx","indexOf","slice","push","findPath","contains","path","child","visit","visitor"],"mappings":"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","file":"trees.js","sourcesContent":["import { array } from \"./arrays\"\n\nexport const tree = (tree, prop) => {\n    let t = tree\n    if(!(tree instanceof Array))\n        if(typeof tree === \"object\")\n            t = [tree]\n        else\n            throw new Error(\"Bad tree format\")\n\n    return {\n        flatten: () => {\n            let flattened = []\n            let fifo = [t]\n            while(fifo.length > 0) {\n                const tree = fifo.pop()\n                if(!(tree instanceof Array))\n                    continue\n                flattened = [ ...array(flattened).notIn(tree), ...tree ]\n                fifo = [ ...fifo, ...tree.filter(item => item[prop]).map(item => item[prop]) ]\n            }\n\n            return flattened\n        },\n        filter: filterFun => {\n            const copy = t.filter(filterFun)\n            const recurse = list => {\n                list.forEach(item => {\n                    if(item[prop] && item[prop] instanceof Array) {\n                        item[prop] = item[prop].filter(filterFun)\n                        recurse(item[prop])\n                    }\n                })\n            }\n            recurse(copy)\n            return copy\n        },\n        treeFilter: filterFun => {\n            const finalMap = new Map()\n\n            const recurse = (list, map) => {\n                list.forEach(item => {\n                    if(item[prop] && item[prop] instanceof Array) {\n                        const childMap = new Map()\n                        recurse(item[prop], childMap)\n                        if(childMap.size > 0) {\n                            map.set(item, childMap)\n                        } else if(filterFun(item)) {\n                            map.set(item, new Map())\n                        }\n                    } else if(filterFun(item)) {\n                        map.set(item, null)\n                    }\n                })\n            }\n            recurse(t, finalMap)\n            return finalMap\n        },\n        add: (parent, elt) => {\n            let fifo = [t]\n            while(fifo.length > 0) {\n                const tree = fifo.pop()\n                const idx = tree.indexOf(parent)\n                if(idx >= 0 && tree[idx][prop]) {\n                    tree[idx][prop] = tree[idx][prop].slice()\n                    tree[idx][prop].push(elt)\n                    return t\n                }\n                fifo = [ ...fifo, ...tree.filter(item => item[prop]).map(item => item[prop]) ]\n            }\n            return t\n        },\n        findPath: elt => {\n            const recurse = item => {\n                if(array(item).contains(elt))\n                    return [item]\n                item[prop].forEach(child => {\n                    const path = recurse(child)\n                    if(path)\n                        return [ ...path, item ]\n                })\n            }\n            return false\n        },\n        visit: visitor => {\n            const fifo = [t]\n            while(fifo.length > 0) {\n                const tree = fifo.pop()\n                visitor(tree)\n                tree.forEach(child => child[prop] && child[prop] instanceof Array ?\n                    fifo.push(child[prop]) :\n                    null)\n            }\n        }\n    }\n}"]}