{"version":3,"sources":["../../src/tools/trees.js"],"names":["array","tree","t","prop","flatten","flattened","fifo","length","pop","Array","notIn","filter","item","map","copy","filterFun","recurse","list","forEach","treeFilter","finalMap","Map","childMap","size","set","add","parent","elt","path","p","visit","visitor","child","push","i","check"],"mappings":"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","file":"trees.js","sourcesContent":["// @flow\n\nimport { array } from \"./arrays\"\n\n// crashes gen-flow-files : type treeMap<T> = Map<T, treeMap<T>>\ntype treeMap<T> = Map<T, *>\ntype treeType<T> = {\n    flatten: () => T[],\n    filter: (T => boolean) => T[],\n    treeFilter: (T => boolean) => treeMap<T>,\n    add: (T, T) => T[],\n    visit: (T[] => void) => void,\n    path: (T) => T[] | boolean\n}\n\nexport const tree = <Item: Object>(t: Item[], prop: string) : treeType<Item> => ({\n    flatten: () => {\n        let flattened : Item[] = []\n        let fifo : Item[][] = [t]\n        while(fifo.length > 0) {\n            const tree: Item[] = fifo.pop()\n            if(!(tree instanceof Array))\n                continue\n            flattened = [ ...array(flattened).notIn(tree), ...tree ]\n            fifo = [ ...fifo, ...tree.filter(item => item[prop]).map(item => item[prop]) ]\n        }\n\n        return flattened\n    },\n    filter: filterFun => {\n        const copy = t.filter(filterFun)\n        const recurse = list => {\n            list.forEach(item => {\n                if(item[prop] && item[prop] instanceof Array) {\n                    item[prop] = item[prop].filter(filterFun)\n                    recurse(item[prop])\n                }\n            })\n        }\n        recurse(copy)\n        return copy\n    },\n    treeFilter: filterFun => {\n        const finalMap = new Map()\n\n        const recurse = (list, map) => {\n            list.forEach(item => {\n                if(item[prop] && item[prop] instanceof Array) {\n                    const childMap = new Map()\n                    recurse(item[prop], childMap)\n                    if(childMap.size > 0) {\n                        map.set(item, childMap)\n                    } else if(filterFun(item)) {\n                        map.set(item, new Map())\n                    }\n                } else if(filterFun(item)) {\n                    map.set(item, null)\n                }\n            })\n        }\n        recurse(t, finalMap)\n        return finalMap\n    },\n    add: (parent, elt) => {\n        const path = tree(t, prop).path(parent)\n        if(path instanceof Array) {\n            parent[prop] = [ ...parent[prop], elt ]\n            path.forEach(p => p[prop] = [...p[prop]])\n            return [...t]\n        } else {\n            return t\n        }\n    },\n    visit: visitor => {\n        const fifo: Item[][] = [t]\n        while(fifo.length > 0) {\n            const tree = fifo.pop()\n            visitor(tree)\n            tree.forEach(child => child[prop] && child[prop] instanceof Array ?\n                fifo.push(child[prop]) :\n                null)\n        }\n    },\n    path: elt => {\n        const recurse = item => {\n            if(item === elt) return []\n            if(!item[prop]) return false\n            for(let i = 0; i < item[prop].length; i++) {\n                const check = recurse(item[prop][i])\n                if(check) return [ item, ...check ]\n            }\n            return false\n        }\n        for(let i = 0; i < t.length; i++) {\n            const check = recurse(t[i])\n            if(check) return check\n        }\n        return false\n    }\n})\n"]}