{"version":3,"sources":["../../src/core/strategies.js"],"names":["array","tree","singleSelect","item","selection","neighbours","ancestors","contains","multiSelect","alreadySelected","newSelection","filter","i","indexOf","inputs","get","category","Array","visit","notIn","children","push","selectionStrategies","single","multiple","modifiers","control","meta","lastSelection","lastIndex","lastPivot","bind","shift","originIndex","slice","endIndex","smaller","higher","deletions","additions","disabled","length","clickStrategies","isSelected","newUnfolded","state","unfolded","set","foldStrategies","recurseCheck","node","some"],"mappings":"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","file":"strategies.js","sourcesContent":["import { array, tree } from \"../tools\"\n\n// Selection strategies are triggered while updating the selection\nconst singleSelect = function(item, selection, neighbours, ancestors) {\n    return array(selection).contains(item) ? [] : [item]\n}\nconst multiSelect = function(item, selection, neighbours, ancestors) {\n    let alreadySelected = false\n    let newSelection = selection.filter(i => {\n        // Mark if the item was already selected\n        if(!alreadySelected) alreadySelected = i === item\n        // Deselect all ancestors\n        return i !== item && ancestors.indexOf(i) < 0\n    })\n    // Categories : deselect all children\n    if(!alreadySelected && item[this.inputs.get().category] && item[this.inputs.get().category] instanceof Array) {\n        tree(item[this.inputs.get().category], this.inputs.get().category).visit(children => {\n            newSelection = array(newSelection).notIn(children)\n        })\n    }\n    if(!alreadySelected) newSelection.push(item)\n    return newSelection\n}\n\nexport const selectionStrategies = {\n    single: singleSelect,\n    multiple: multiSelect,\n    modifiers: function(item, selection, neighbours, ancestors) {\n        if(this.modifiers.control || this.modifiers.meta) {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return multiSelect.bind(this)(item, selection, neighbours, ancestors)\n        } else if(this.modifiers.shift) {\n            if(!this.lastSelection)\n                return selection\n\n            const originIndex = neighbours.indexOf(this.lastSelection)\n            if(originIndex < 0)\n                return selection\n\n            let newSelection = selection.slice()\n            const endIndex = neighbours.indexOf(item)\n\n            if(originIndex >= 0) {\n                if(this.lastPivot) {\n                    const lastIndex = neighbours.indexOf(this.lastPivot)\n                    const [ smaller, higher ] = originIndex > lastIndex ?\n                            [ lastIndex, originIndex ] :\n                            [ originIndex, lastIndex ]\n                    const deletions = neighbours.slice(smaller, higher + 1)\n                    newSelection = array(newSelection).notIn(deletions)\n                }\n                this.lastPivot = item\n\n                const [ smaller, higher ] = originIndex > endIndex ?\n                        [ endIndex, originIndex ] :\n                        [ originIndex, endIndex ]\n                const additions = !this.inputs.get().disabled ?\n                    neighbours.slice(smaller, higher + 1) :\n                    neighbours.slice(smaller, higher + 1).filter(i => !this.inputs.get().disabled(i))\n                newSelection = array(newSelection).notIn(additions)\n                newSelection.push(...additions)\n            }\n\n            return newSelection\n        } else {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return singleSelect(item, selection.length > 1 ? [] : selection, neighbours, ancestors)\n        }\n    }\n}\n\n// Click strategies are triggered on item click\nexport const clickStrategies = {\n    \"unfold-on-selection\": function(item) {\n        if(!this.isSelected(item)) {\n            const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n            newUnfolded.push(item)\n            this.state.set({ unfolded: newUnfolded })\n        }\n    },\n    \"toggle-fold\": function(item) {\n        const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n        if(newUnfolded.length === this.state.get().unfolded.length) {\n            newUnfolded.push(item)\n        }\n        this.state.set({ unfolded: newUnfolded })\n    }\n}\n\n// Fold strategies are triggered during render to fold / unfold children\nexport const foldStrategies = {\n    \"opener-control\": function(item) {\n        return !array(this.state.get().unfolded).contains(item)\n    },\n    \"not-selected\": function(item) {\n        return !this.isSelected(item)\n    },\n    \"no-child-selection\": function(item) {\n        // naive ...\n        const recurseCheck = node =>\n            this.isSelected(node) ||\n            node[this.inputs.get().category] &&\n            node[this.inputs.get().category] instanceof Array &&\n            node[this.inputs.get().category].some(recurseCheck)\n        return !recurseCheck(item)\n    }\n}"]}