{"version":3,"sources":["../../src/core/strategies.js"],"names":["array","tree","singleSelect","item","selection","neighbours","ancestors","contains","multiSelect","alreadySelected","newSelection","filter","i","indexOf","inputs","get","category","Array","visit","children","notIn","push","selectionStrategies","single","multiple","modifiers","control","meta","lastSelection","lastIndex","lastPivot","bind","shift","originIndex","slice","endIndex","smaller","higher","deletions","additions","disabled","length","clickStrategies","isSelected","newUnfolded","state","unfolded","set","foldStrategies","recurseCheck","node","some","maxDepth","isNaN","parseInt","depth"],"mappings":"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","file":"strategies.js","sourcesContent":["// @flow\n\nimport { array, tree } from \"../tools\"\n\ntype clickStrategy = (item: Object, event: MouseEvent, ancestors: Array<Object>, neighbours: Array<Object>) => void\ntype foldStrategy = (item: Object, folded: boolean) => boolean\n\n// Selection strategies are triggered while updating the selection\nconst singleSelect = function(item: Object, selection: Object[], neighbours: Object[], ancestors: Object[]) {\n    return array(selection).contains(item) ? [] : [item]\n}\nconst multiSelect = function(item: Object, selection: Object[], neighbours: Object[], ancestors: Object[]) {\n    let alreadySelected = false\n    let newSelection = selection.filter(i => {\n        // Mark if the item was already selected\n        if(!alreadySelected) alreadySelected = i === item\n        // Deselect all ancestors\n        return i !== item && ancestors.indexOf(i) < 0\n    })\n    // Categories : deselect all children\n    if(!alreadySelected && item[this.inputs.get().category] && item[this.inputs.get().category] instanceof Array) {\n        tree(item[this.inputs.get().category], this.inputs.get().category).visit((children: any) => {\n            newSelection = array(newSelection).notIn(children)\n        })\n    }\n    if(!alreadySelected) newSelection.push(item)\n    return newSelection\n}\n\nexport const selectionStrategies = {\n    single: singleSelect,\n    multiple: multiSelect,\n    modifiers: function(item: Object, selection: Object[], neighbours: Object[], ancestors: Object[]) {\n        if(this.modifiers.control || this.modifiers.meta) {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return multiSelect.bind(this)(item, selection, neighbours, ancestors)\n        } else if(this.modifiers.shift) {\n            if(!this.lastSelection)\n                return selection\n\n            const originIndex = neighbours.indexOf(this.lastSelection)\n            if(originIndex < 0)\n                return selection\n\n            let newSelection = selection.slice()\n            const endIndex = neighbours.indexOf(item)\n\n            if(originIndex >= 0) {\n                if(this.lastPivot) {\n                    const lastIndex = neighbours.indexOf(this.lastPivot)\n                    const [ smaller, higher ] = originIndex > lastIndex ?\n                            [ lastIndex, originIndex ] :\n                            [ originIndex, lastIndex ]\n                    const deletions : any = neighbours.slice(smaller, higher + 1)\n                    newSelection = array(newSelection).notIn(deletions)\n                }\n                this.lastPivot = item\n\n                const [ smaller, higher ] = originIndex > endIndex ?\n                        [ endIndex, originIndex ] :\n                        [ originIndex, endIndex ]\n                const additions : any = !this.inputs.get().disabled ?\n                    neighbours.slice(smaller, higher + 1) :\n                    neighbours.slice(smaller, higher + 1).filter(i => !this.inputs.get().disabled(i))\n                newSelection = array(newSelection).notIn(additions)\n                newSelection.push(...additions)\n            }\n\n            return newSelection\n        } else {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return singleSelect.bind(this)(item, selection.length > 1 ? [] : selection, neighbours, ancestors)\n        }\n    },\n    ancestors: function(item: Object, selection: Object[], neighbours: Object[], ancestors: Object[]) {\n        return selection.length === 0 ?\n                [item] :\n            array(selection).contains(item) ?\n                [...ancestors] :\n            [ ...ancestors, item ]\n    }\n}\n\n// Click strategies are triggered on item click\nexport const clickStrategies : { [key: string] : clickStrategy } = {\n    \"unfold-on-selection\": function(item: Object) {\n        if(!this.isSelected(item)) {\n            const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n            newUnfolded.push(item)\n            this.state.set({ unfolded: newUnfolded })\n        }\n    },\n    \"toggle-fold\": function(item: Object) {\n        const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n        if(newUnfolded.length === this.state.get().unfolded.length) {\n            newUnfolded.push(item)\n        }\n        this.state.set({ unfolded: newUnfolded })\n    }\n}\n\n// Fold strategies are triggered during render to fold / unfold children\nexport const foldStrategies : { [key: string] : foldStrategy } = {\n    \"opener-control\": function(item: Object) {\n        return !array(this.state.get().unfolded).contains(item)\n    },\n    \"not-selected\": function(item: Object) {\n        return !this.isSelected(item)\n    },\n    \"no-child-selection\": function(item: Object) {\n        // naive ...\n        const recurseCheck = node =>\n            this.isSelected(node) ||\n            node[this.inputs.get().category] &&\n            node[this.inputs.get().category] instanceof Array &&\n            node[this.inputs.get().category].some(recurseCheck)\n        return !recurseCheck(item)\n    },\n    \"max-depth\": function() {\n        return this.inputs.get().maxDepth && !isNaN(parseInt(this.inputs.get().maxDepth, 10)) ?\n            this.inputs.get().depth >= parseInt(this.inputs.get().maxDepth, 10) :\n            false\n    }\n}\n"]}