{"version":3,"sources":["../../src/core/strategies.js"],"names":["array","tree","singleSelect","item","selection","neighbours","ancestors","contains","multiSelect","alreadySelected","newSelection","filter","i","indexOf","inputs","get","category","Array","visit","children","notIn","push","selectionStrategies","single","multiple","modifiers","control","meta","lastSelection","lastIndex","lastPivot","bind","shift","originIndex","slice","endIndex","smaller","higher","deletions","additions","disabled","length","clickStrategies","select","onSelect","model","isSelected","newUnfolded","state","unfolded","set","foldStrategies","recurseCheck","node","some","maxDepth","isNaN","parseInt","depth"],"mappings":"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","file":"strategies.js","sourcesContent":["// @flow\n\nimport { array, tree } from \"@bosket/tools\"\n\ntype selectionStrategy = (item: Object, selection: Object[], neighbours: Object[], ancestors: Object[]) => Object[]\ntype clickStrategy = (item: Object, event: MouseEvent, inputs: Object) => void\ntype foldStrategy = (item: Object, folded: boolean) => boolean\n\nconst singleSelect : selectionStrategy = function(item, selection, neighbours, ancestors) {\n    return array(selection).contains(item) ? [] : [item]\n}\nconst multiSelect : selectionStrategy = function(item, selection, neighbours, ancestors) {\n    let alreadySelected = false\n    let newSelection = selection.filter(i => {\n        // Mark if the item was already selected\n        if(!alreadySelected) alreadySelected = i === item\n        // Deselect all ancestors\n        return i !== item && ancestors.indexOf(i) < 0\n    })\n    // Categories : deselect all children\n    if(!alreadySelected && item[this.inputs.get().category] && item[this.inputs.get().category] instanceof Array) {\n        tree(item[this.inputs.get().category], this.inputs.get().category).visit((children: any) => {\n            newSelection = array(newSelection).notIn(children)\n        })\n    }\n    if(!alreadySelected) newSelection.push(item)\n    return newSelection\n}\n\n// Selection strategies are triggered when the selection is updated.\nexport const selectionStrategies : { [key: string] : selectionStrategy } = {\n    // The single strategy allows only one selected item at the same time (usually the last item clicked).\n    single: singleSelect,\n    // The multiple strategy allows any number of selected items and will add the last item clicked to the selection list.\n    multiple: multiSelect,\n    /*\n    The modifiers strategy is the way most file explorers behave.\n    Without keyboard modifiers, only one selected item is allowed.\n    While pressing the shift key, all items between the two last selected siblings are added to the selection array.\n    While pressing the ctrl (or cmd for mac users) key, the item is added to the selection list.\n     */\n    modifiers: function(item, selection, neighbours, ancestors) {\n        if(this.modifiers.control || this.modifiers.meta) {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return multiSelect.bind(this)(item, selection, neighbours, ancestors)\n        } else if(this.modifiers.shift) {\n            if(!this.lastSelection)\n                return selection\n\n            const originIndex = neighbours.indexOf(this.lastSelection)\n            if(originIndex < 0)\n                return selection\n\n            let newSelection = selection.slice()\n            const endIndex = neighbours.indexOf(item)\n\n            if(originIndex >= 0) {\n                if(this.lastPivot) {\n                    const lastIndex = neighbours.indexOf(this.lastPivot)\n                    const [ smaller, higher ] = originIndex > lastIndex ?\n                        [ lastIndex, originIndex ] :\n                        [ originIndex, lastIndex ]\n                    const deletions : any = neighbours.slice(smaller, higher + 1)\n                    newSelection = array(newSelection).notIn(deletions)\n                }\n                this.lastPivot = item\n\n                const [ smaller, higher ] = originIndex > endIndex ?\n                    [ endIndex, originIndex ] :\n                    [ originIndex, endIndex ]\n                const additions : any = !this.inputs.get().disabled ?\n                    neighbours.slice(smaller, higher + 1) :\n                    neighbours.slice(smaller, higher + 1).filter(i => !this.inputs.get().disabled(i))\n                newSelection = array(newSelection).notIn(additions)\n                newSelection.push(...additions)\n            }\n\n            return newSelection\n        } else {\n            this.lastSelection = item\n            delete this.lastIndex\n            delete this.lastPivot\n            return singleSelect.bind(this)(item, selection.length > 1 ? [] : selection, neighbours, ancestors)\n        }\n    },\n    // Selects an item and its ancestors.\n    ancestors: function(item, selection, neighbours, ancestors) {\n        return selection.length === 0 ?\n            [item] :\n            array(selection).contains(item) ?\n                [...ancestors] :\n                [ ...ancestors, item ]\n    }\n}\n\n// Click strategies are triggered on item click\nexport const clickStrategies : { [key: string] : clickStrategy } = {\n    // Selects on click\n    select: function(item) {\n        this.inputs.get().onSelect(item, this.inputs.get().ancestors, this.inputs.get().model)\n    },\n    // Unfold an item when selecting it. Pair it with the \"opener-control\" fold strategy.\n    \"unfold-on-selection\": function(item) {\n        if(!this.isSelected(item)) {\n            const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n            newUnfolded.push(item)\n            this.state.set({ unfolded: newUnfolded })\n        }\n    },\n    // Toggle fold/unfold. Pair it with the \"opener-control\" fold strategy.\n    \"toggle-fold\": function(item) {\n        const newUnfolded = this.state.get().unfolded.filter(i => i !== item)\n        if(newUnfolded.length === this.state.get().unfolded.length) {\n            newUnfolded.push(item)\n        }\n        this.state.set({ unfolded: newUnfolded })\n    }\n}\n\n// Fold strategies determine if an item will be folded or not, meaning if its children are hidden.\nexport const foldStrategies : { [key: string] : foldStrategy } = {\n    // Allow the opener (usually an arrow-like element) to control the fold state.\n    \"opener-control\": function(item) {\n        return !array(this.state.get().unfolded).contains(item)\n    },\n    // Fold when not selected.\n    \"not-selected\": function(item) {\n        return !this.isSelected(item)\n    },\n    // Unfold as long as there is at least one child selected.\n    \"no-child-selection\": function(item) {\n        // naive algorithm ...\n        const recurseCheck = node =>\n            this.isSelected(node) ||\n            node[this.inputs.get().category] &&\n            node[this.inputs.get().category] instanceof Array &&\n            node[this.inputs.get().category].some(recurseCheck)\n        return !recurseCheck(item)\n    },\n    // Fold every item deeper than then \"max-depth\" component property.\n    \"max-depth\": function() {\n        return this.inputs.get().maxDepth && !isNaN(parseInt(this.inputs.get().maxDepth, 10)) ?\n            this.inputs.get().depth >= parseInt(this.inputs.get().maxDepth, 10) :\n            false\n    }\n}\n"]}